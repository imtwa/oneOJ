/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50726
Source Host           : localhost:3306
Source Database       : oneoj

Target Server Type    : MYSQL
Target Server Version : 50726
File Encoding         : 65001

Date: 2023-12-26 09:58:21
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for oj_problem
-- ----------------------------
DROP TABLE IF EXISTS `oj_problem`;
CREATE TABLE `oj_problem` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `path` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `degree` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `time_limit` int(11) DEFAULT '3000',
  `memory_limit` int(11) DEFAULT '65536',
  `describe_pro` varchar(2048) CHARACTER SET utf8 DEFAULT NULL COMMENT '描述',
  `in_describe` varchar(2048) CHARACTER SET utf8 DEFAULT NULL,
  `out_describe` varchar(2048) COLLATE utf8_unicode_ci DEFAULT NULL,
  `in_sample` varchar(2048) CHARACTER SET utf8 DEFAULT NULL,
  `out_sample` varchar(2048) COLLATE utf8_unicode_ci DEFAULT NULL,
  `tip` varchar(2048) CHARACTER SET utf8 DEFAULT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `visible` int(11) DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=244 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
-- Records of oj_problem
-- ----------------------------
INSERT INTO `oj_problem` VALUES ('1', '超级玛丽游戏', '/dataOJ/1.1.10超级玛丽游戏', '简单', '3000', '65536', '超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。\n\n', '无。\n', '如样例所示。\n', '（无）\n', '\n                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('2', 'Hello, World!', '/dataOJ/1.1.1Hello, World!', '简单', '3000', '65536', '对于大部分编程语言来说，编写一个能够输出“Hello, World!”的程序往往是最基本、最简单的。因此，这个程序常常作为一个初学者接触一门新的编程语言所写的第一个程序，也经常用来测试开发、编译环境是否能够正常工作。\n\n现在你就需要完成这样一个程序。\n\n', '无。\n', '一行，仅包含一个字符串：“Hello, World!”\n', '（无）\n', 'Hello, World!\n', '使用英文标点符号；逗号后面有一个空格。\n', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('3', '字符菱形', '/dataOJ/1.1.9字符菱形', '简单', '3000', '65536', '给定一个字符，用它构造一个对角线长5个字符，倾斜放置的菱形。\n\n', '输入只有一行， 包含一个字符。\n', '该字符构成的菱形。\n', '*\n', '  *\n ***\n*****\n ***\n  *\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('4', '单词排序', '/dataOJ/1.10.10单词排序', '简单', '3000', '65536', '输入一行单词序列，相邻单词之间由1个或多个空格间隔，请按照字典序输出这些单词，要求重复的单词只输出一次。（区分大小写）\n\n', '一行单词序列，最少1个单词，最多100个单词，每个单词长度不超过50，单词之间用至少1个空格间隔。数据不含除字母、空格外的其他字符。\n', '按字典序输出这些单词，重复的单词只输出一次。\n', 'She  wants  to go to Peking University to study  Chinese\n', 'Chinese\nPeking\nShe\nUniversity\ngo\nstudy\nto\nwants\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('5', '谁考了第k名', '/dataOJ/1.10.1谁考了第k名', '简单', '3000', '65536', '在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。\n\n', '第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。\n其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。\n', '输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）\n', '5 3\n90788001 67.8\n90788002 90.3\n90788003 61\n90788004 68.4\n90788005 73.9\n', '90788004 68.4\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('6', '奇数单增序列', '/dataOJ/1.10.2奇数单增序列', '简单', '3000', '65536', '给定一个长度为N（不大于500）的正整数序列，请将其中的所有奇数取出，并按升序输出。\n\n', '共2行：\n第1行为 N；\n第2行为 N 个正整数，其间用空格间隔。\n', '增序输出的奇数序列，数据之间以逗号间隔。数据保证至少有一个奇数。\n', '10\n1 3 2 6 5 4 9 8 7 10\n', '1,3,5,7,9\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('7', '成绩排序', '/dataOJ/1.10.3成绩排序', '简单', '3000', '65536', '给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则名字字典序小的在前。\n\n', '第一行为n (0 < n < 20)，表示班里的学生数目；\n接下来的n行，每行为每个学生的名字和他的成绩, 中间用单个空格隔开。名字只包含字母且长度不超过20，成绩为一个不大于100的非负整数。\n', '把成绩单按分数从高到低的顺序进行排序并输出，每行包含名字和分数两项，之间有一个空格。\n', '4\nKitty 80\nHanmeimei 90\nJoey 92\nTim 28\n', 'Joey 92\nHanmeimei 90 \nKitty 80\nTim 28\n', '相同成绩按名字从小到大排序', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('8', '奖学金', '/dataOJ/1.10.4奖学金', '简单', '3000', '65536', '某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。\n\n任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:\n\n7 279\n\n5 279\n\n这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是:\n\n5 279\n\n7 279\n\n则按输出错误处理，不能得分。\n\n', '包含n+1行:\n\n第1行为一个正整数n，表示该校参加评选的学生人数。\n\n第2到n+1行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为 j-1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1~n (恰好是输入数据的行号减1)。\n\n所给的数据都是正确的，不必检验。\n\n50%的数据满足:各学生的总成绩各不相同；\n100%的数据满足: 6<=n<=300。\n', '共有5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。\n', '样例 #1：\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n\n样例 #2：\n8\n80 89 89 \n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n\n', '样例 #1：\n6 265\n4 264\n3 258\n2 244\n1 237\n\n样例 #2：\n8 265\n2 264\n6 264\n1 258\n5 258\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('9', '分数线划定', '/dataOJ/1.10.5分数线划定', '简单', '3000', '65536', '世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的150%划定，即如果计划录取m名志愿者，则面试分数线为排名第m*150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。\n\n现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。\n\n', '第一行，两个整数n，m（5 ≤ n ≤ 5000，3 ≤ m ≤ n），中间用一个空格隔开，其中n 表示报名参加笔试的选手总数，m 表示计划录取的志愿者人数。输入数据保证m*150%向下取整后小于等于n。\n第二行到第 n+1 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号k（1000 ≤ k ≤ 9999）和该选手的笔试成绩s（1 ≤ s ≤ 100）。数据保证选手的报名号各不相同。\n', '第一行，有两个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。\n从第二行开始，每行包含两个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。\n', '6 3\n1000 90\n3239 88\n2390 95\n7231 84\n1005 95\n1001 88\n', '88 5\n1005 95\n2390 95\n1000 90\n1001 88\n3239 88\n', '样例说明：m*150% = 3*150% = 4.5，向下取整后为4。保证4个人进入面试的分数线为88，但因为88有重分，所以所有成绩大于等于88的选手都可以进入面试，故最终有5个人进入面试。\n', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('10', '整数奇偶排序', '/dataOJ/1.10.6整数奇偶排序', '简单', '3000', '65536', '给定10个整数的序列，要求对其重新排序。排序要求:\n\n1.奇数在前，偶数在后；\n\n2.奇数按从大到小排序；\n\n3.偶数按从小到大排序。\n\n', '输入一行，包含10个整数，彼此以一个空格分开，每个整数的范围是大于等于0，小于等于100。\n', '按照要求排序后输出一行，包含排序后的10个整数，数与数之间以一个空格分开。\n', '4 7 3 13 11 12 0 47 34 98\n', '47 13 11 7 3 0 4 12 34 98\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('11', '合影效果', '/dataOJ/1.10.7合影效果', '简单', '3000', '65536', '小云和朋友们去爬香山，为美丽的景色所陶醉，想合影留念。如果他们站成一排，男生全部在左（从拍照者的角度），并按照从矮到高的顺序从左到右排，女生全部在右，并按照从高到矮的顺序从左到右排，请问他们合影的效果是什么样的（所有人的身高都不同）？\n\n', '第一行是人数n（2 <= n <= 40，且至少有1个男生和1个女生）。\n后面紧跟n行，每行输入一个人的性别（男male或女female）和身高（浮点数，单位米），两个数据之间以空格分隔。\n', 'n个浮点数，模拟站好队后，拍照者眼中从左到右每个人的身高。每个浮点数需保留到小数点后2位，相邻两个数之间用单个空格隔开。\n', '6\nmale 1.72\nmale 1.78\nfemale 1.61\nmale 1.65\nfemale 1.70\nfemale 1.56\n', '1.65 1.72 1.78 1.70 1.61 1.56\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('12', '病人排队', '/dataOJ/1.10.8病人排队', '简单', '3000', '65536', '病人登记看病，编写一个程序，将登记的病人按照以下原则排出看病的先后顺序：\n1. 老年人（年龄 >= 60岁）比非老年人优先看病。\n2. 老年人按年龄从大到小的顺序看病，年龄相同的按登记的先后顺序排序。\n3. 非老年人按登记的先后顺序看病。\n', '第1行，输入一个小于100的正整数，表示病人的个数；\n后面按照病人登记的先后顺序，每行输入一个病人的信息，包括：一个长度小于10的字符串表示病人的ID（每个病人的ID各不相同且只含数字和字母），一个整数表示病人的年龄，中间用单个空格隔开。\n', '按排好的看病顺序输出病人的ID，每行一个。\n', '5\n021075 40\n004003 15\n010158 67\n021033 75\n102012 30\n', '021033\n010158\n021075\n004003\n102012\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('13', '明明的随机数', '/dataOJ/1.10.9明明的随机数', '简单', '3000', '65536', '明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n\n', '有2行，第1行为1个正整数，表示所生成的随机数的个数：N；\n第2行有N个用空格隔开的正整数，为所产生的随机数。\n', '也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n', '10\n20 40 32 67 40 20 89 300 400 15\n', '8\n15 20 32 40 67 89 300 400\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('14', '河中跳房子', '/dataOJ/1.11.10河中跳房子', '中等', '3000', '65536', '每年奶牛们都要举办各种特殊版本的跳房子比赛，包括在河里从一个岩石跳到另一个岩石。这项激动人心的活动在一条长长的笔直河道中进行，在起点和离起点L远 (1 ≤ L≤ 1,000,000,000) 的终点处均有一个岩石。在起点和终点之间，有N (0 ≤ N ≤ 50,000) 个岩石，每个岩石与起点的距离分别为Di (0 < Di < L)。\n\n在比赛过程中，奶牛轮流从起点出发，尝试到达终点，每一步只能从一个岩石跳到另一个岩石。当然，实力不济的奶牛是没有办法完成目标的。\n\n农夫约翰为他的奶牛们感到自豪并且年年都观看了这项比赛。但随着时间的推移，看着其他农夫的胆小奶牛们在相距很近的岩石之间缓慢前行，他感到非常厌烦。他计划移走一些岩石，使得从起点到终点的过程中，最短的跳跃距离最长。他可以移走除起点和终点外的至多M (0 ≤ M ≤ N) 个岩石。\n\n请帮助约翰确定移走这些岩石后，最长可能的最短跳跃距离是多少？\n\n\n\n', '第一行包含三个整数L, N, M，相邻两个整数之间用单个空格隔开。\n接下来N行，每行一个整数，表示每个岩石与起点的距离。岩石按与起点距离从近到远给出，且不会有两个岩石出现在同一个位置。\n', '一个整数，最长可能的最短跳跃距离。\n', '25 5 2\n2\n11\n14\n17\n21\n', '4\n', '在移除位于2和14的两个岩石之后，最短跳跃距离为4（从17到21或从21到25）。\n', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('15', '查找最接近的元素', '/dataOJ/1.11.1查找最接近的元素', '简单', '3000', '65536', '在一个非降序列中，查找与给定值最接近的元素。\n\n', '第一行包含一个整数n，为非降序列长度。1 <= n <= 100000。\n第二行包含n个整数，为非降序列各元素。所有元素的大小均在0-1,000,000,000之间。\n第三行包含一个整数m，为要询问的给定值个数。1 <= m <= 10000。\n接下来m行，每行一个整数，为要询问最接近元素的给定值。所有给定值的大小均在0-1,000,000,000之间。\n', 'm行，每行一个整数，为最接近相应给定值的元素值，保持输入顺序。若有多个值满足条件，输出最小的一个。\n', '3\n2 5 8\n2\n10\n5\n', '8\n5\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('16', '二分法求函数的零点', '/dataOJ/1.11.2二分法求函数的零点', '简单', '3000', '65536', '有函数：\n\nf(x) = x5 - 15 * x4+ 85 * x3- 225 * x2+ 274 * x - 121\n\n已知 f(1.5) > 0 , f(2.4) < 0 且方程 f(x) = 0 在区间 [1.5,2.4] 有且只有一个根，请用二分法求出该根。\n\n', '无。\n', '该方程在区间[1.5,2.4]中的根。要求四舍五入到小数点后6位。\n', '无\n', '不提供\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('17', '矩形分割', '/dataOJ/1.11.3矩形分割', '简单', '3000', '65536', '平面上有一个大矩形，其左下角坐标（0，0），右上角坐标（R,R)。大矩形内部包含一些小矩形，小矩形都平行于坐标轴且互不重叠。所有矩形的顶点都是整点。要求画一根平行于y轴的直线x=k（k是整数) ，使得这些小矩形落在直线左边的面积必须大于等于落在右边的面积，且两边面积之差最小。并且，要使得大矩形在直线左边的的面积尽可能大。注意：若直线穿过一个小矩形，将会把它切成两个部分，分属左右两侧。\n\n', '第一行是整数R，表示大矩形的右上角坐标是(R,R) (1 <= R <= 1,000,000)。\n接下来的一行是整数N,表示一共有N个小矩形(0 < N <= 10000)。\n再接下来有N 行。每行有4个整数，L,T, W 和 H, 表示有一个小矩形的左上角坐标是(L,T),宽度是W，高度是H (0<=L,T <= R, 0 < W,H <= R). 小矩形不会有位于大矩形之外的部分。\n', '输出整数n，表示答案应该是直线 x=n。 如果必要的话，x=R也可以是答案。\n', '1000\n2\n1 1 2 1\n5 1 2 1\n', '5\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('18', '网线主管', '/dataOJ/1.11.4网线主管', '困难', '3000', '65536', '仙境的居民们决定举办一场程序设计区域赛。裁判委员会完全由自愿组成，他们承诺要组织一次史上最公正的比赛。他们决定将选手的电脑用星形拓扑结构连接在一起，即将它们全部连到一个单一的中心服务器。为了组织这个完全公正的比赛，裁判委员会主席提出要将所有选手的电脑等距离地围绕在服务器周围放置。\n\n为购买网线，裁判委员会联系了当地的一个网络解决方案提供商，要求能够提供一定数量的等长网线。裁判委员会希望网线越长越好，这样选手们之间的距离可以尽可能远一些。\n\n该公司的网线主管承接了这个任务。他知道库存中每条网线的长度（精确到厘米），并且只要告诉他所需的网线长度（精确到厘米），他都能够完成对网线的切割工作。但是，这次，所需的网线长度并不知道，这让网线主管不知所措。\n\n你需要编写一个程序，帮助网线主管确定一个最长的网线长度，并且按此长度对库存中的网线进行切割，能够得到指定数量的网线。\n\n', '第一行包含两个整数N和K，以单个空格隔开。N（1 <= N <= 10000）是库存中的网线数，K（1 <= K <= 10000）是需要的网线数量。\n接下来N行，每行一个数，为库存中每条网线的长度（单位：米）。所有网线的长度至少1m，至多100km。输入中的所有长度都精确到厘米，即保留到小数点后两位。\n', '网线主管能够从库存的网线中切出指定数量的网线的最长长度（单位：米）。必须精确到厘米，即保留到小数点后两位。\n若无法得到长度至少为1cm的指定数量的网线，则必须输出“0.00”（不包含引号）。\n', '4 11\n8.02\n7.43\n4.57\n5.39\n', '2.00\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('19', '派', '/dataOJ/1.11.5派', '简单', '3000', '65536', '我的生日要到了！根据习俗，我需要将一些派分给大家。我有N个不同口味、不同大小的派。有F个朋友会来参加我的派对，每个人会拿到一块派（必须一个派的一块，不能由几个派的小块拼成；可以是一整个派）。\n\n我的朋友们都特别小气，如果有人拿到更大的一块，就会开始抱怨。因此所有人拿到的派是同样大小的（但不需要是同样形状的），虽然这样有些派会被浪费，但总比搞砸整个派对好。当然，我也要给自己留一块，而这一块也要和其他人的同样大小。\n\n请问我们每个人拿到的派最大是多少？每个派都是一个高为1，半径不等的圆柱体。\n\n', '第一行包含两个正整数N和F，1 ≤ N, F ≤ 10 000，表示派的数量和朋友的数量。\n第二行包含N个1到10000之间的整数，表示每个派的半径。\n', '输出每个人能得到的最大的派的体积，精确到小数点后三位。\n', '3 3\n4 3 3\n', '25.133\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('20', '月度开销', '/dataOJ/1.11.6月度开销', '简单', '3000', '65536', '农夫约翰是一个精明的会计师。他意识到自己可能没有足够的钱来维持农场的运转了。他计算出并记录下了接下来 N (1 ≤ N ≤ 100,000) 天里每天需要的开销。\n\n约翰打算为连续的M (1 ≤ M ≤ N) 个财政周期创建预算案，他把一个财政周期命名为fajo月。每个fajo月包含一天或连续的多天，每天被恰好包含在一个fajo月里。\n\n约翰的目标是合理安排每个fajo月包含的天数，使得开销最多的fajo月的开销尽可能少。\n\n\n\n', '第一行包含两个整数N,M，用单个空格隔开。\n接下来N行，每行包含一个1到10000之间的整数，按顺序给出接下来N天里每天的开销。\n', '一个整数，即最大月度开销的最小值。\n', '7 5\n100\n400\n300\n100\n500\n101\n400\n', '500\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('21', '和为给定数', '/dataOJ/1.11.7和为给定数', '简单', '3000', '65536', '给出若干个整数，询问其中是否有一对数的和等于给定的数。\n\n', '共三行：\n第一行是整数n(0 < n <= 100,000)，表示有n个整数。\n第二行是n个整数。整数的范围是在0到10^8之间。\n第三行是一个整数m（0 <= m <= 2^30)，表示需要得到的和。\n', '若存在和为m的数对，输出两个整数，小的在前，大的在后，中间用单个空格隔开。若有多个数对满足条件，选择数对中较小的数更小的。若找不到符合要求的数对，输出一行No。\n', '4\n2 5 1 4\n6\n', '1 5\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('22', '不重复地输出数', '/dataOJ/1.11.8不重复地输出数', '简单', '3000', '65536', '输入n个数，从小到大将它们输出，重复的数只输出一次。保证不同的数不超过500个。\n\n', '第一行是一个整数n。1 <= n <= 100000。\n之后n行，每行一个整数。整数大小在int范围内。\n', '一行，从小到大不重复地输出这些数，相邻两个数之间用单个空格隔开。\n', '5\n2 4 4 5 1\n', '1 2 4 5\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('23', '膨胀的木棍', '/dataOJ/1.11.9膨胀的木棍', '简单', '3000', '65536', '当长度为L的一根细木棍的温度升高n度，它会膨胀到新的长度L\'=(1+n*C)*L，其中C是热膨胀系数。\n当一根细木棍被嵌在两堵墙之间被加热，它将膨胀形成弓形的弧，而这个弓形的弦恰好是未加热前木棍的原始位置。\n你的任务是计算木棍中心的偏移距离。\n \n', '三个非负实数：木棍初始长度（单位：毫米），温度变化（单位：度），以及材料的热膨胀系数。\n保证木棍不会膨胀到超过原始长度的1.5倍。\n', '木棍中心的偏移距离（单位：毫米），保留到小数点后第三位。\n', '1000 100 0.0001\n', '61.329\n\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('24', '素数对', '/dataOJ/1.12.10素数对', '简单', '3000', '65536', '两个相差为2的素数称为素数对，如5和7，17和19等，本题目要求找出所有两个数均不大于n的素数对。\n\n', '一个正整数n。1 <= n <= 10000。\n', '所有小于等于n的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出empty。\n', '100\n', '3 5\n5 7\n11 13\n17 19\n29 31\n41 43\n59 61\n71 73\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('25', '简单算术表达式求值', '/dataOJ/1.12.1简单算术表达式求值', '简单', '3000', '65536', '两位正整数的简单算术运算（只考虑整数运算），算术运算为：\n\n+，加法运算；\n-，减法运算；\n*，乘法运算；\n/，整除运算；\n%，取余运算。\n\n算术表达式的格式为（运算符前后可能有空格）：\n运算数 运算符 运算数\n\n请输出相应的结果。\n\n', '一行算术表达式。\n', '整型算数运算的结果（结果值不一定为2位数，可能多于2位或少于2位）。\n', '32+64\n', '96\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('26', '短信计费', '/dataOJ/1.12.2短信计费', '简单', '3000', '65536', '用手机发短信，一条短信资费为0.1元，但限定一条短信的内容在70个字以内（包括70个字）。如果你一次所发送的短信超过了70个字，则会按照每70个字一条短信的限制把它分割成多条短信发送。假设已经知道你当月所发送的短信的字数，试统计一下你当月短信的总资费。\n\n', '第一行是整数n，表示当月发送短信的总次数，接着n行每行一个整数，表示每次短信的字数。\n', '输出一行，当月短信总资费，单位为元，精确到小数点后1位。\n', '10\n39\n49\n42\n61\n44\n147\n42\n72\n35\n46\n', '1.3\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('27', '甲流病人初筛', '/dataOJ/1.12.3甲流病人初筛', '简单', '3000', '65536', '目前正是甲流盛行时期，为了更好地进行分流治疗，医院在挂号时要求对病人的体温和咳嗽情况进行检查，对于体温超过37.5度（含等于37.5度）并且咳嗽的病人初步判定为甲流病人（初筛）。现需要统计某天前来挂号就诊的病人中有多少人被初筛为甲流病人。\n\n', '第一行是某天前来挂号就诊的病人数n。（n < 200）\n其后有n行，每行是病人的信息，包括三个信息：姓名（字符串，不含空格，最多8个字符）、体温（float）、是否咳嗽（整数，1表示咳嗽，0表示不咳嗽）。每行三个信息之间以一个空格分开。\n', '按输入顺序依次输出所有被筛选为甲流的病人的姓名，每个名字占一行。之后在输出一行，表示被筛选为甲流的病人数量。\n', '5\nZhang 38.3 0\nLi 37.5 1\nWang 37.1 1\nZhao 39.0 1\nLiu 38.2 1\n', 'Li\nZhao\nLiu\n3\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('28', '最匹配的矩阵', '/dataOJ/1.12.4最匹配的矩阵', '简单', '3000', '65536', '给定一个m*n的矩阵A和r*s的矩阵B,其中0 < r ≤ m, 0 < s ≤ n，A、B所有元素值都是小于100的正整数。求A中一个大小为r*s的子矩阵C，使得B和C的对应元素差值的绝对值之和最小，这时称C为最匹配的矩阵。如果有多个子矩阵同时满足条件，选择子矩阵左上角元素行号小者，行号相同时，选择列号小者。\n\n', '第一行是m和n，以一个空格分开。\n之后m行每行有n个整数，表示A矩阵中的各行，数与数之间以一个空格分开。\n第m+2行为r和s，以一个空格分开。\n之后r行每行有s个整数，表示B矩阵中的各行，数与数之间以一个空格分开。\n（1 ≤ m ≤ 100,1 ≤ n ≤ 100）\n', '输出矩阵C，一共r行，每行s个整数，整数之间以一个空格分开。\n', '3 3\n3 4 5\n5 3 4\n8 2 4\n2 2\n7 3\n4 9\n', '4 5 \n3 4 \n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('29', '统计单词数', '/dataOJ/1.12.5统计单词数', '简单', '3000', '65536', '一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。\n\n现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2）。\n\n', '2 行。\n第 1 行为一个字符串，其中只含字母，表示给定单词；\n第 2 行为一个字符串，其中只可能包含字母和空格，表示给定的文章。\n', '只有一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从0开始）；如果单词在文章中没有出现，则直接输出一个整数-1。\n', '样例 #1：\nTo\nto be or not to be is a question\n\n样例 #2：\nto\nDid the Ottoman Empire lose its power at that time\n', '样例 #1：\n2 0\n\n样例 #2：\n-1\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('30', '寻宝', '/dataOJ/1.12.6寻宝', '简单', '3000', '65536', '传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏 宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：\n\n藏宝楼共有 N+1 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 N 层，每层 M 个房间，这 M 个房间围成一圈并按逆时针方向依次编号为 0，…， M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 x，表示从这个房间开始按逆时针方向选择第 x 个有楼梯的房间（假定该房间的编号为 k），从该房间上楼，上楼后到达上一层的 k 号房间。比如当前房间的指示牌上写着 2，则按逆时针方向开始尝试，找到第 2 个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。\n\n寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。\n\n请帮助小明算出这个打开宝箱的密钥。\n\n', '第一行 2 个整数 N 和 M，之间用一个空格隔开。N 表示除了顶层外藏宝楼共 N 层楼， M 表示除顶层外每层楼有 M 个房间。\n接下来 N*M 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第(i-1)*M+j 行表示第 i 层 j-1 号房间的情况（i=1, 2, …, N；j=1, 2, … ,M）。第一个整数表示该房间是否有楼梯通往上一层（0 表示没有，1 表示有），第二个整数表示指示牌上的数字。注意，从 j 号房间的楼梯爬到上一层到达的房间一定也是 j 号房间。\n最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 0 开始）。\n\n对于50%数据，有 0< N ≤ 1000，0 < x ≤ 10000；\n对于100%数据，有 0 < N ≤ 10000，0 < M ≤ 100，0 < x ≤ 1,000,000。\n', '输出只有一行，一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 20123 取模的结果即可。\n', '2 3\n1 2\n0 3\n1 4\n0 1\n1 5\n1 2\n1\n', '5\n', '输入输出样例说明：\n\n第一层：\n0 号房间，有楼梯通往上层，指示牌上的数字是 2；\n1 号房间，无楼梯通往上层，指示牌上的数字是 3；\n2 号房间，有楼梯通往上层，指示牌上的数字是 4；\n\n第二层：\n0 号房间，无楼梯通往上层，指示牌上的数字是 1；\n1 号房间，有楼梯通往上层，指示牌上的数字是 5；\n2 号房间，有楼梯通往上层，指示牌上的数字是 2；\n\n小明首先进入第一层（底层）的 1 号房间，记下指示牌上的数字为 3，然后从这个房间 开始，沿逆时针方向选择第 3 个有楼梯的房间 2 号房间进入，上楼后到达第二层的 2 号房间， 记下指示牌上的数字为 2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第 2 个有楼梯的房间即为 1 号房间，进入后上楼梯到达 顶层。这时把上述记下的指示牌上的数字加起来，即 3+2=5，所以打开宝箱的密钥就是 5。\n', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('31', '机器翻译', '/dataOJ/1.12.7机器翻译', '简单', '3000', '65536', '小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。\n\n这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。\n\n假设内存中有M个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。\n\n假设一篇英语文章的长度为N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。\n\n', '输入文件共2行。每行中两个数之间用一个空格隔开。\n第一行为两个正整数M和N，代表内存容量和文章的长度。\n第二行为N个非负整数，按照文章的顺序，每个数（大小不超过1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。\n\n对于10%的数据有M = 1，N ≤ 5。\n对于100%的数据有0 < M ≤ 100，0 < N ≤ 1000。\n', '共1行，包含一个整数，为软件需要查词典的次数。\n', '样例 #1：\n3 7\n1 2 1 5 4 4 1\n\n样例 #2：\n2 10\n8 824 11 78 11 78 11 78 8 264\n', '样例 #1：\n5\n\n样例 #2：\n6\n', '输入输出样例 1 说明：\n\n整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：\n\n空：内存初始状态为空。\n1． 1：查找单词1并调入内存。\n2． 1 2：查找单词2并调入内存。\n3． 1 2：在内存中找到单词1。\n4． 1 2 5：查找单词5并调入内存。\n5． 2 5 4：查找单词4并调入内存替代单词1。\n6． 2 5 4：在内存中找到单词4。\n7． 5 4 1：查找单词1并调入内存替代单词2。\n\n共计查了5 次词典。\n', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('32', 'Vigenère密码', '/dataOJ/1.12.8Vigenère密码', '简单', '3000', '65536', '16世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。\n在密码学中，我们称需要加密的信息为明文，用M表示；称加密后的信息为密文，用C表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。 在Vigenère密码中，密钥k是一个字母串，k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中ci=mi®ki，运算®的规则如下表所示：\n \nVigenère加密在操作时需要注意：\n1. ®运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式；\n2. 当明文M的长度大于密钥k的长度时，将密钥k重复使用。\n例如，明文M=Helloworld，密钥k=abc时，密文C=Hfnlpyosnd。\n明文	H	e	l	l	o	w	o	r	l	d\n密钥	a	b	c	a	b	c	a	b	c	a\n密文	H	f	n	l	p	y	o	s	n	d\n\n', '输入共2行。\n第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二行为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母。\n\n对于100%的数据，输入的密钥的长度不超过100，输入的密文的长度不超过1000，且都仅包含英文字母。\n', '输出共1行，一个字符串，表示输入密钥和密文所对应的明文。\n', 'CompleteVictory\nYvqgpxaimmklongnzfwpvxmniytm\n', 'Wherethereisawillthereisaway\n\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('33', '图像旋转翻转变换', '/dataOJ/1.12.9图像旋转翻转变换', '简单', '3000', '65536', '给定m行n列的图像各像素点灰度值，对其依次进行一系列操作后，求最终图像。\n\n其中，可能的操作及对应字符有如下四种：\n\nA：顺时针旋转90度；\n\nB：逆时针旋转90度；\n\nC：左右翻转；\n\nD：上下翻转。\n\n', '第一行包含两个正整数m和n，表示图像的行数和列数，中间用单个空格隔开。1 <= m <= 100, 1 <= n <= 100。\n接下来m行，每行n个整数，表示图像中每个像素点的灰度值，相邻两个数之间用单个空格隔开。灰度值范围在0到255之间。\n接下来一行，包含由A、B、C、D组成的字符串s，表示需要按顺序执行的操作序列。s的长度在1到100之间。\n', 'm\'行，每行包含n\'个整数，为最终图像各像素点的灰度值。其中m\'为最终图像的行数，n\'为最终图像的列数。相邻两个整数之间用单个空格隔开。\n', '2 3\n10 0 10\n100 100 10\nAC\n', '10 100\n0 100\n10 10\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('34', '判决素数个数', '/dataOJ/1.13.10判决素数个数', '简单', '3000', '65536', '输入两个整数X和Y，输出两者之间的素数个数（包括X和Y）。\n\n', '两个整数X和Y（1 <= X,Y <= 105）。\n', '输出一个整数，表示X，Y之间的素数个数（包括X和Y）。\n', '1 100\n', '25\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('35', '回文素数', '/dataOJ/1.13.11回文素数', '简单', '3000', '65536', '一个数如果从左往右读和从右往左读数字是相同的，则称这个数是回文数，如121，1221，15651都是回文数。给定位数n，找出所有既是回文数又是素数的n位十进制数。（注：不考虑超过整型数范围的情况）。\n', '位数n,其中1<=n<=9。\n', '第一行输出满足条件的素数个数。\n第二行按照从小到大的顺序输出所有满足条件的素数，两个数之间用一个空格区分。\n', '1\n', '4\n2 3 5 7\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('36', '分数求和', '/dataOJ/1.13.12分数求和', '简单', '3000', '65536', '输入n个分数并对他们求和，并用最简形式表示。所谓最简形式是指：分子分母的最大公约数为1；若最终结果的分母为1，则直接用整数表示。\n\n如：5/6、10/3均是最简形式，而3/6需要化简为1/2, 3/1需要化简为3。\n\n分子和分母均不为0，也不为负数。\n\n', '第一行是一个整数n，表示分数个数，1 <= n <= 10；\n接下来n行，每行一个分数，用\"p/q\"的形式表示，不含空格，p，q均不超过10。\n', '输出只有一行，即最终结果的最简形式。若为分数，用\"p/q\"的形式表示。\n', '2\n1/2\n1/3\n', '5/6\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('37', '人民币支付', '/dataOJ/1.13.13人民币支付', '简单', '3000', '65536', '从键盘输入一指定金额（以元为单位，如345），然后输出支付该金额的各种面额的人民币数量，显示100元，50元，20元，10元，5元，1元各多少张，要求尽量使用大面额的钞票。\n\n', '一个小于1000的正整数。\n', '输出分行，每行显示一个整数，从上到下分别表示100元，50元，20元，10元，5元，1元人民币的张数\n', '735\n', '7\n0\n1\n1\n1\n0\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('38', '求满足条件的3位数', '/dataOJ/1.13.14求满足条件的3位数', '简单', '3000', '65536', '编写程序，按从小到大的顺序寻找同时符合条件1和2的所有3位数，条件为：\n1.该数为完全平方数\n2.该数至少有2位数字相同\n例如，100同时满足上面两个条件。\n\n', '输入一个数n，n的大小不超过实际满足条件的3位数的个数。\n', '输出为第n个满足条件的3位数(升序)\n', '1\n', '100\n', '无', '2023-12-03 23:52:49', '1');
INSERT INTO `oj_problem` VALUES ('39', '求序列中的众数', '/dataOJ/1.13.15求序列中的众数', '简单', '3000', '65536', '输入一个长度为N的整数序列 (不多于128个整数)，每个整数的范围在[-1052,1052]，计算这个序列的众数。\n\n众数是指出现次数最多的那个数。\n\n如果有多个数出现的次数都达到最多，则取在原序列最先出现的数为众数；如果所有的数都相等，则返回\"no\"。\n\n', '第一行为序列长度N。\n\n然后是N个数，每一个数的范围都是在[-10^52,10^52]。 注意，这N个数之间可能有若干个空行隔开。\n\n注意，输入数据可能有一些冗余表达信息，具体来说：\n\n1） 正数和0前面可能有前导0和\'+\'符号，例如\n+000123=123\n+0000=0\n-0000=0\n2）每个数字中不含有空格和其他非数字字符，例如不会出现\"100 0\"或者\"- 100\"。\n3）每个数字前面至多有一个符号，即不会出现+(-1)、-(+4)和-(-1)等情况。\n', '输出只有 1 行：\n\n该序列的众数或者”no”。\n\n如果有多个数出现的次数都达到最多，则取最先出现的数为众数，并且输出形式应该最简形式。\n\n例如，如果原序列众数为+000123，则输出123；如果原序列众数为+0000或者-0000或者0000,输出0。\n\n负数正常输出，例如：如果原序列众数为-000000001111，就输出-1111。\n', '6\n-00001\n10000\n00011111111111111111111111111111111111\n-01\n+000000011111111111111111111111111111111111\n-00000000000001\n', '-1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('40', '最长单词2', '/dataOJ/1.13.16最长单词2', '简单', '3000', '65536', '一个以\'.\'结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式，求句子中的最长单词。\n\n', '一个以\'.\'结尾的简单英文句子（长度不超过500），单词之间用空格分隔，没有缩写形式和其它特殊形式。\n', '该句子中最长的单词。如果多于一个，则输出第一个\n', 'I am a student of Peking University.\n', 'University\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('41', '文字排版', '/dataOJ/1.13.17文字排版', '简单', '3000', '65536', '给一段英文短文，单词之间以空格分隔（每个单词包括其前后紧邻的标点符号）。请将短文重新排版，要求如下：\n\n每行不超过80个字符；每个单词居于同一行上；在同一行的单词之间以一个空格分隔；行首和行尾都没有空格。\n\n', '第一行是一个整数n，表示英文短文中单词的数目. 其后是n个以空格分隔的英文单词（单词包括其前后紧邻的标点符号，且每个单词长度都不大于40个字母）。\n', '排版后的多行文本，每行文本字符数最多80个字符，单词之间以一个空格分隔，每行文本首尾都没有空格。\n', '84\nOne sweltering day, I was scooping ice cream into cones and told my four children they could \"buy\" a cone from me for a hug. Almost immediately, the kids lined up to make their purchases. The three youngest each gave me a quick hug, grabbed their cones and raced back outside. But when my teenage son at the end of the line finally got his turn to \"buy\" his ice cream, he gave me two hugs. \"Keep the changes,\" he said with a smile. \n', 'One sweltering day, I was scooping ice cream into cones and told my four\nchildren they could \"buy\" a cone from me for a hug. Almost immediately, the kids\nlined up to make their purchases. The three youngest each gave me a quick hug,\ngrabbed their cones and raced back outside. But when my teenage son at the end\nof the line finally got his turn to \"buy\" his ice cream, he gave me two hugs.\n\"Keep the changes,\" he said with a smile.\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('42', 'Tomorrow never knows？', '/dataOJ/1.13.18Tomorrow never knows？', '简单', '3000', '65536', '甲壳虫的《A day in the life》和《Tomorrow never knows》脍炙人口，如果告诉你a day in the life,真的会是tomorrow never knows?相信学了计概之后这个不会是难题，现在就来实现吧。\n\n读入一个格式为yyyy-mm-dd的日期（即年－月－日），输出这个日期下一天的日期。可以假定输入的日期不早于1600-01-01，也不晚于2999-12-30。\n\n', '输入仅一行，格式为yyyy-mm-dd的日期。\n', '输出也仅一行，格式为yyyy-mm-dd的日期\n', '2010-07-05\n', '2010-07-06\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('43', '啤酒厂选址', '/dataOJ/1.13.19啤酒厂选址', '简单', '3000', '65536', '海上有一个岛，在环海边上建有一条环岛高速公路，沿着公路有n（5 < n < 10000）个居民点，假设每个居民点有一个编号，从0开始，按顺时针依次从小到大（即，0,1，…，n-1）编号。在岛上啤酒很受青睐。某啤酒企业计划在岛上投资建一个啤酒厂，并根据啤酒需求每天向居住点送啤酒。已知两个相邻的居民点的距离以及每个居住点每天的啤酒需求量（假设每个居住点每天不超过2000桶）。假定每单位长度的路程送一桶啤酒需要的费用恒定（为单位费用）。请问，选择哪一个居民点建啤酒厂，才能使每天送啤酒的费用最小（空车不计费用）。\n\n', '第一行：为居民点数目n\n后面为n行，每行为一个居民点的啤酒需求量以及按顺时针离下一个居民点的距离（均为整数,空格间隔），从编号为0的开始，按单增顺次给出。\n\n注意：后面第n行对应于居民点（n-1)的啤酒需求量以及到编号为0的居民点距离。\n', '啤酒厂所在的居民点编号以及每天的运输费用，其间以逗号间隔\n', '6\n500 10\n300 30\n350 25\n400 60\n700 28\n200 35\n', '0,94100\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('44', '数制转换', '/dataOJ/1.13.1数制转换', '简单', '3000', '65536', '求任意两个不同进制非负整数的转换（2进制～16进制），所给整数在long所能表达的范围之内。\n不同进制的表示符号为（0，1，...，9，a，b，...，f）或者（0，1，...，9，A，B，...，F）。\n\n', '输入只有一行，包含三个整数a，n，b。a表示其后的n 是a进制整数，b表示欲将a进制整数n转换成b进制整数。\na，b是十进制整数，2 =< a，b <= 16。\n', '输出包含一行，该行有一个整数为转换后的b进制数。输出时字母符号全部用大写表示，即（0，1，...，9，A，B，...，F）。\n', '15 Aab3 7\n', '210306\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('45', '话题焦点人物', '/dataOJ/1.13.20话题焦点人物', '简单', '3000', '65536', '微博提供了一种便捷的交流平台。一条微博中，可以提及其它用户。例如Lee发出一条微博为：“期末考试顺利 @Kim @Neo”，则Lee提及了Kim和Neo两位用户。\n\n我们收集了N(1 < N < 10000)条微博，并已将其中的用户名提取出来，用小于等于100的正整数表示。\n\n通过分析这些数据，我们希望发现大家的话题焦点人物，即被提及最多的人（题目保证这样的人有且只有一个），并找出那些提及它的人。\n\n', '输入共两部分：\n第一部分是微博数量N，1 < N < 10000。\n第二部分是N条微博，每条微博占一行，表示为：\n发送者序号a，提及人数k(0 < = k < = 20)，然后是k个被提及者序号b1,b2...bk；\n其中a和b1,b2...bk均为大于0小于等于100的整数。相邻两个整数之间用单个空格分隔。\n', '输出分两行：\n第一行是被提及最多的人的序号；\n第二行是提及它的人的序号，从小到大输出，相邻两个数之间用单个空格分隔。同一个序号只输出一次。\n', '5\n1 2 3 4\n1 0\n90 3 1 2 4\n4 2 3 2\n2 1 3\n', '3\n1 2 4\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('46', '最大质因子序列', '/dataOJ/1.13.21最大质因子序列', '简单', '3000', '65536', '任意输入两个正整数m, n (1 < m < n <= 5000)，依次输出m到n之间每个数的最大质因子（包括m和n；如果某个数本身是质数，则输出这个数自身）。\n\n', '一行，包含两个正整数m和n，其间以单个空格间隔。\n', '一行，每个整数的最大质因子，以逗号间隔。\n', '5 10\n', '5,3,7,2,3,5\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('47', '因子分解', '/dataOJ/1.13.22因子分解', '简单', '3000', '65536', '输入一个数，输出其素因子分解表达式。\n\n', '输入一个整数 n (2 <= n < 100)。\n', '输出该整数的因子分解表达式。\n表达式中各个素数从小到大排列。\n如果该整数可以分解出因子a的b次方，当b大于1时，写做 a^b ；当b等于1时，则直接写成a。\n', '60\n', '2^2*3*5\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('48', '区间内的真素数', '/dataOJ/1.13.23区间内的真素数', '简单', '3000', '65536', '找出正整数 M 和 N 之间（N 不小于 M）的所有真素数。\n\n真素数的定义：如果一个正整数 P 为素数，且其反序也为素数，那么 P 就为真素数。\n例如，11，13 均为真素数，因为11的反序还是为11，13 的反序为 31 也为素数。\n\n', '输入两个数 M 和 N，空格间隔，1 <= M <= N <= 100000。\n', '按从小到大输出 M 和 N 之间（包括 M 和 N ）的真素数，逗号间隔。如果之间没有真素数，则输出 No。\n', '10 35\n', '11,13,17,31\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('49', '打印月历', '/dataOJ/1.13.24打印月历', '简单', '3000', '65536', '给定年月，打印当月的月历表。\n\n', '输入为一行两个整数，第一个整数是年份year（1900 ≤ year ≤ 2099），第二个整数是月份month（1 ≤ month ≤ 12），中间用单个空格隔开。\n', '输出为月历表。月历表第一行为星期表头，如下所示：\nSun Mon Tue Wed Thu Fri Sat\n其余各行一次是当月各天的日期，从1日开始到31日（30日或28日）。\n日期数字应于星期表头右对齐，即各位数与星期表头相应缩写的最后一个字母对齐。日期中间用空格分隔出空白。\n', '2006 5\n', 'Sun Mon Tue Wed Thu Fri Sat\n      1   2   3   4   5   6\n  7   8   9  10  11  12  13\n 14  15  16  17  18  19  20\n 21  22  23  24  25  26  27\n 28  29  30  31\n', '闰年判断方法：能被4整除但不能被100整除，或者能被400整除。\n1900年1月1日是周一。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('50', '计算两个日期之间的天数', '/dataOJ/1.13.25计算两个日期之间的天数', '简单', '3000', '65536', '给定两个日期，计算相差的天数。比如2010-1-1和2010-1-3相差2天。\n\n\n', '共两行：\n第一行包含三个整数startYear，startMonth，startDay，分别是起始年、月、日。\n第二行包含三个整数endYear，endMonth，endDay，分别是结束年、月、日。\n相邻两个整数之间用单个空格隔开。\n\n年份范围在1~3000。保证日期正确且结束日期不早于起始日期。\n', '输出一个整数，即是两个日期相差的天数。\n', '2008 1 1\n2009 1 1\n', '366\n', '闰年被定义为能被4整除的年份，但是能被100整除而不能被400整除的年是例外，它们不是闰年。闰年的2月份有29天。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('51', 'n-gram串频统计', '/dataOJ/1.13.26n-gram串频统计', '简单', '3000', '65536', '在文本分析中常用到n-gram串频统计方法，即，统计相邻的n个单元（如单词、汉字、或者字符）在整个文本中出现的频率。假设有一个字符串，请以字符为单位，按n-gram方法统计每个长度为 n 的子串出现的频度，并输出最高频度以及频度最高的子串。所给的字符串只包含大小写字母，长度不多于500个字符，且 1 < n < 5。\n\n如果有多个子串频度最高，则根据其在序列中第一次出现的次序依次输出，每行输出一个，如果最高频度不大于1，则输出NO。\n\n', '第一行为n；\n第二行为字符串。\n', '输出最高频度以及频度最高的所有子串。若最高频度不大于1，只输出一行NO。\n', '3\nabcdefabcd\n', '2\nabc\nbcd\n', '样例中，所有的3-gram是：abc,bcd,cde,def,efa,fab,abc,bcd。最后面的cd不足以形成3-gram，则不考虑。这样，abc 和 bcd 都出现了2次，其余的只出现了1次。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('52', '除以13', '/dataOJ/1.13.27除以13', '简单', '3000', '65536', '输入一个大于0的大整数N，长度不超过100位，要求输出其除以13得到的商和余数。\n\n', '一个大于0的大整数，长度不超过100位。\n', '两行，分别为整数除法得到的商和余数。\n', '2132104848488485\n', '164008065268345\n0\n', '模拟除法运算，商的长度应该比输入大整数的长度少1或2。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('53', '出现次数超过一半的数', '/dataOJ/1.13.28出现次数超过一半的数', '简单', '3000', '65536', '给出一个含有n（0 < n <= 1000）个整数的数组，请找出其中出现次数超过一半的数。\n\n数组中的数大于-50且小于50。\n\n', '第一行包含一个整数n，表示数组大小；\n第二行包含n个整数，分别是数组中的每个元素，相邻两个元素之间用单个空格隔开。\n', '如果存在这样的数，输出这个数；否则输出no。\n', '3\n1 2 2\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('54', '统计字符数', '/dataOJ/1.13.29统计字符数', '简单', '3000', '65536', '给定一个由a-z这26个字符组成的字符串，统计其中哪个字符出现的次数最多。\n\n', '输入包含一行，一个字符串，长度不超过1000。\n', '输出一行，包括出现次数最多的字符和该字符出现的次数，中间以一个空格分开。如果有多个字符出现的次数相同且最多，那么输出ascii码最小的那一个字符。\n', 'abbccc\n', 'c 3\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('55', '不吉利日期', '/dataOJ/1.13.2不吉利日期', '简单', '3000', '65536', '在国外，每月的13号和每周的星期5都是不吉利的。特别是当13号那天恰好是星期5时，更不吉利。已知某年的一月一日是星期w，并且这一年一定不是闰年，求出这一年所有13号那天是星期5的月份，按从小到大的顺序输出月份数字。（w=1..7）\n\n', '输入有一行，即一月一日星期几（w）。（1 <= w <= 7）\n', '输出有一到多行，每行一个月份，表示该月的13日是星期五。\n', '7\n', '1\n10\n', '1、3、5、7、8、10、12月各有31天\n4、6、9、11月各有30天\n2月有28天\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('56', '-1的个数', '/dataOJ/1.13.30-1的个数', '简单', '3000', '65536', '给定一个十进制非负整数N，求其对应2进制数中1的个数。\n\n', '输入包含一行，包含一个非负整数N。(N < 109)\n', '输出一行，包含一个整数，表示N的2进制表示中1的个数。\n', '100\n', '3\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('57', '字符串中最长的连续出现的字符', '/dataOJ/1.13.31字符串中最长的连续出现的字符', '简单', '3000', '65536', '求一个字符串中最长的连续出现的字符，输出该字符及其出现次数。字符串中无空白字符（空格、回车和tab），如果这样的字符不止一个，则输出出现最早的字符。\n\n', '一行，一个不包含空白字符的字符串，字符串长度小于200。\n', '一行，输出最长的连续出现的字符及其最长的连续出现次数，中间以一个空格分开。\n', 'aaaaadbbbbbcccccccdddddddddd\n', 'd 10\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('58', '日历问题', '/dataOJ/1.13.32日历问题', '简单', '3000', '65536', '在我们现在使用的日历中, 闰年被定义为能被4整除的年份，但是能被100整除而不能被400整除的年是例外，它们不是闰年。例如：1700, 1800, 1900 和 2100 不是闰年，而 1600, 2000 和 2400是闰年。 给定从公元2000年1月1日开始逝去的天数，你的任务是给出这一天是哪年哪月哪日星期几。\n\n', '输入一行，每行包含一个正整数，表示从2000年1月1日开始逝去的天数。数据保证结果的年份不会超过9999。\n', '输出一行，该行包含对应的日期和星期几。格式为“YYYY-MM-DD DayOfWeek”, 其中 “DayOfWeek” 必须是下面中的一个： \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" 或 \"Saturday“。\n', '1\n', '2000-01-02 Sunday\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('59', '实数加法', '/dataOJ/1.13.33实数加法', '简单', '3000', '65536', '求2个实数相加的和。\n\n输入输出中出现的实数都有如下的形式： P1P2...Pi.Q1Q2...Qj。对于整数部分，P1P2...Pi是一个非负整数；对于小数部分，至少有一位且最后一位Qj不等于0。\n\n', '2行，分别是两个加数。每个加数不超过100个字符。\n', '一行输出是相应的和。数据保证一定是一个小数部分不为0的实数。\n', '0.111111111111111111111111111111\n0.111111111111111111111111111111\n', '0.222222222222222222222222222222\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('60', '确定进制', '/dataOJ/1.13.34确定进制', '简单', '3000', '65536', '6 * 9 = 42 对于十进制来说是错误的，但是对于13进制来说是正确的。即, 6(13)* 9(13)= 42(13)， 而 42(13)= 4 * 131+ 2 * 130= 54(10)。\n\n你的任务是写一段程序，读入三个整数p、q和 r，然后确定一个进制 B(2<=B<=16) 使得 p * q = r。 如果 B 有很多选择, 输出最小的一个。\n\n例如：p = 11, q = 11, r = 121. 则有 11(3)* 11(3)= 121(3)因为 11(3)= 1 * 31+ 1 * 30= 4(10)和 121(3)= 1 * 32+ 2 * 31+ 1 * 30= 16(10)。 对于进制 10，同样有 11(10)* 11(10)= 121(10)。这种情况下，应该输出 3。如果没有合适的进制，则输出 0。\n\n', '一行，包含三个整数p、q、r。 p、q、r的所有位都是数字，并且1 <= p、q、r <= 1,000,000。\n', '一个整数：即使得p * q = r成立的最小的B。如果没有合适的B，则输出 0。\n', '6 9 42\n', '13\n来源\nTaejon 2002, POJ 1331, 程序设计实习07\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('61', '输出二进制补码', '/dataOJ/1.13.35输出二进制补码', '简单', '3000', '65536', '输入一个整型(int)的整数，输出它的32位二进制补码。\n\n', '一个整型整数。\n', '输出一行，即该整数的补码表示。\n', '7\n', '00000000000000000000000000000111\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('62', '乒乓球', '/dataOJ/1.13.37乒乓球', '简单', '3000', '65536', '国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。\n\n华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。\n\n比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：\n\nWWWWWWWWWWWWWWWWWWWWWWLW\n\n在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。\n\n你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。\n\n', '包含若干行字符串（每行至多20个字母），字符串由大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。\n', '输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。\n', 'WWWWWWWWWWWWWWWWWWWW\nWWLWE\n', '11:0\n11:0\n1:1\n\n21:0\n2:1\n', '按乒乓球比赛规则，每一局中，领先一方达到一定得分（11分制为11分，21分制为21分），且净胜对手至少2分，才能够获得胜利；\n本题中，假设比赛无局数限制；\n输入字符串总长可能很长。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('63', '花生采摘', '/dataOJ/1.13.38花生采摘', '简单', '3000', '65536', '鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。\n鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图1）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”\n我们假定多多在每个单位时间内，可以做下列四件事情中的一件：\n1)      从路边跳到最靠近路边（即第一行）的某棵花生植株；\n2)      从一棵植株跳到前后左右与之相邻的另一棵植株；\n3)      采摘一棵植株下的花生；\n4)      从最靠近路边（即第一行）的某棵花生植株跳回路边。\n \n现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。\n例如在图2所示的花生田里，只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为13, 7, 15, 9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。\n', '第一行包括三个整数，M, N和K，用空格隔开；表示花生田的大小为M * N（1 <= M, N <= 20），多多采花生的限定时间为K（0 <= K <= 1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i + 1行的第j个整数Pij（0 <= Pij <= 500）表示花生田里植株(i, j)下花生的数目，0表示该植株下没有花生。\n', '包括一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。\n', '样例 #1：\n6 7 21\n0 0 0 0 0 0 0\n0 0 0 0 13 0 0\n0 0 0 0 0 0 7\n0 15 0 0 0 0 0\n0 0 0 9 0 0 0\n0 0 0 0 0 0 0\n\n样例 #2：\n6 7 20\n0 0 0 0 0 0 0\n0 0 0 0 13 0 0\n0 0 0 0 0 0 7\n0 15 0 0 0 0 0\n0 0 0 9 0 0 0\n0 0 0 0 0 0 0\n', '样例 #1：\n37\n\n样例 #2：\n28\n\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('64', '多项式输出', '/dataOJ/1.13.39多项式输出', '简单', '3000', '65536', '一元 n 次多项式可用如下的表达式表示：\n\nf(x)=anxn+an-1xn-1+...+a1x+a0，an≠0\n\n其中，aixi称为i次项，ai称为i次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：\n\n1. 多项式中自变量为x，从左到右按照次数递减顺序给出多项式。\n\n2. 多项式中只包含系数不为0的项。\n\n3. 如果多项式n次项系数为正，则多项式开头不出现“+”号，如果多项式n次项系数为负，则多项式以“-”号开头。\n\n4. 对于不是最高次的项，以“+”号或者“-”号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于0次的项，其系数的绝对值为1，则无需输出1）。如果x的指数大于1，则接下来紧跟的指数部分的形式为“x^b”，其中b为x的指数；如果x的指数为1，则接下来紧跟的指数部分形式为“x”； 如果x的指数为0，则仅需输出系数即可。\n\n5. 多项式中，多项式的开头、结尾不含多余的空格。\n\n', '共有2 行：\n第一行 1 个整数 n，表示一元多项式的次数。\n第二行有 n+1 个整数，其中第 i 个整数表示第 n-i+1 次项的系数，每两个整数之间用空格隔开。\n\n1 ≤ n ≤ 100，多项式各次项系数的绝对值均不超过100。\n', '共1行，按题目所述格式输出多项式。\n', '样例 #1：\n5\n100 -1 1 -3 0 10\n\n样例 #2：\n3\n-50 0 0 1\n', '样例 #1：\n100x^5-x^4+x^3-3x^2+10\n\n样例 #2：\n-50x^3+1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('65', '八进制小数', '/dataOJ/1.13.3八进制小数', '简单', '3000', '65536', '八进制有限小数均可以用十进制有限小数精确地表示。比如，八进制里面的0.75等于十进制里面的0.963125 (7/8 + 5/64)。所有小数点后位数为n的八进制小数都可以表示成小数点后位数不多于3n的十进制小数。\n\n你的任务是写一个程序，把(0,1)之间的八进制小数转化成十进制小数。\n\n', '一行，包含一个八进制小数。每个小数的形式是0.d1d2d3 ... dk，这里di是八进制数0...7，dk不等于0，而且已知0 < k < 15。\n', '输入如下形式的一行\n\n0.d1d2d3...dk [8] = 0.D1D2D3...Dm [10]\n\n\n这里左边是输入的八进制小数，右边是相等的十进制小数。输出的小数末尾不能有0，也就是说Dm不等于0。注意空格位置。\n', '0.75\n', '0.75 [8] = 0.953125 [10]\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('66', '提取数字串按数值排序', '/dataOJ/1.13.40提取数字串按数值排序', '简单', '3000', '65536', '给定一个字符串，请将其中的所有数字串提取，并将每个数字串作为整数看待（假设可以用int 表示），按从小到大顺序输出结果，输出的整数之间以逗号间隔。如果没有数字，则输出0；例如：*1234.345#6781ad9jk81-11101?aght88ir09kp，其中的整数包括：1234，345，6781，9，81，11101，88，9，从小到大排序后，应该输出：\n9，9，81，88，345，1234，6781，11101\n\n', '在一行内输入一串符号，长度不大于300。输入数据保证提取的整数不超过109。\n', '从小到大排序的整数序列，如果没有数字，则输出0；\n', '*1234.345#6781ad9jk81-11101?aght88ir09kp\n', '9,9,81,88,345,1234,6781,11101\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('67', '判断元素是否存在', '/dataOJ/1.13.41判断元素是否存在', '简单', '3000', '65536', '有一个集合M是这样生成的： (1) 已知 k 是集合 M 的元素； (2) 如果 y 是 M 的元素，那么， 2y+1 和 3y+1 都是 M 的元素； (3) 除了上述二种情况外，没有别的数能够成为 M 的一个元素。\n\n问题：任意给定 k 和 x，请判断 x 是否是 M 的元素。这里的 k是无符号整数，x 不大于 100000， 如果是，则输出YES，否则，输出 NO\n\n', '输入整数 k 和 x, 逗号间隔。\n', '如果是，则输出 YES，否则，输出NO\n', '0,22\n', 'YES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('68', '出书最多', '/dataOJ/1.13.42出书最多', '简单', '3000', '65536', '假定图书馆新进了m（10 ≤ m ≤ 999）本图书，它们都是由n（1 ≤ n ≤ 26）个作者独立或相互合作编著的。假设m本图书编号为整数（1到999），作者的姓名为字母（\'A\'到\'Z\'），请根据图书作者列表找出参与编著图书最多的作者和他的图书列表。\n\n', '第一行为所进图书数量m，其余m行，每行是一本图书的信息，其中第一个整数为图书编号，接着一个空格之后是一个由大写英文字母组成的没有重复字符的字符串，每个字母代表一个作者。输入数据保证仅有一个作者出书最多。\n', '输出有多行：\n第一行为出书最多的作者字母；\n第二行为作者出书的数量；\n其余各行为作者参与编著的图书编号（按输入顺序输出）。\n', '11\n307 F\n895 H\n410 GPKCV\n567 SPIM\n822 YSHDLPM\n834 BXPRD\n872 LJU\n791 BPJWIA\n580 AGMVY\n619 NAFL\n233 PDJWXK\n', 'P\n6\n410\n567\n822\n834\n791\n233\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('69', '相关月', '/dataOJ/1.13.43相关月', '简单', '3000', '65536', '“相关月”是指那些在一年中月份的第一天星期数相同的月份。例如，九月和十二月是相关的，因为九月一日和十二月一日的星期数总是相同的。两个月份相关，当且仅当两个月份第一天相差的天数能被7整除，也就是说，这两天相差为几个整星期。又如，二月和三月一般都是相关月，因为二月有28天，能被7整除，也恰好为4个星期。而在闰年，一月和二月的相关月与它们在平年的相关月是不同的，因为二月有29天，其后每个月份的第一天星期数都推后了一天。\n\n', '输入的第一行为整数n（n ≤ 200），\n其后n行，每行三个整数，依次为一个年份和两个月份，整数之间用一个空格分隔。\n', '输出有n行，对应于每个输入的年份和相应两个月份，\n如果这两个月份是相关的，则输出YES；\n否则，输出NO。\n', '5\n1994 10 9\n1935 12 1\n1957 1 9\n1917 9 12\n1948 1 4\n', 'NO\nNO\nNO\nYES\nYES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('70', '十进制到八进制', '/dataOJ/1.13.44十进制到八进制', '简单', '3000', '65536', '把一个十进制正整数转化成八进制。\n\n', '一行，仅含一个十进制表示的整数a(0 < a < 65536)。\n', '一行，a的八进制表示。\n', '9\n', '11\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('71', '正整数的任意进制转换', '/dataOJ/1.13.44正整数的任意进制转换', '简单', '3000', '65536', '将 p 进制 n 转换为 q 进制。p 和 q 的取值范围为[2，36]，其中，用到的数码按从小到大依次为：0，1，2，3，4，5，6，7，8，9，A，B，...，Z，不考虑小写字母。\n\n\n\n\n', '一共1+m 行：\n第1行为 m，表示后面有 m 行（1 <= m <= 60）.\n其后的m行中，每行3个数: 进制p，p进制数n，以及进制 q。\n三个数之间用逗号间隔。\nn 的长度不超过50位。\n', '转换后的 q 进制数。\n', '6\n18,2345678A123,18\n15,23456,18\n12,2345678,20\n16,12345678,23\n25,3456AB,21\n18,AB1234567,22\n', '2345678A123\n114E0\n22B7A4\n21A976L\n7C2136\n22JF0G367\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('72', '八进制到十进制', '/dataOJ/1.13.45八进制到十进制', '简单', '3000', '65536', '把一个八进制正整数转化成十进制。\n\n', '一行，仅含一个八进制表示的正整数a，a的十进制表示的范围是(0, 65536)。\n', '一行，a的十进制表示。\n', '11\n', '9\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('73', '大整数除法', '/dataOJ/1.13.47大整数除法', '简单', '3000', '65536', '求两个大的正整数相除的商。\n\n', '第1行是被除数，第2行是除数。每个数均不超过100位。\n', '一行，相应的商的整数部分\n', '2376\n24\n', '99\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('74', '实数加法', '/dataOJ/1.13.48实数加法', '简单', '3000', '65536', '求两个实数相加的和。\n\n题目中输入输出里出现的浮点数都有如下的形式：\nP1P2...Pi.Q1Q2...Qj。对于整数部分，P1P2...Pi是一个非负整数且当整数部分不为0时，P1不等于0；对于小数部分，Qj不等于0。\n\n', '2行，每行是一个加数。每个加数的长度不超过100。\n', '一行，即相应的和。输出保证一定是一个小数部分不为0的实数。\n', '0.111111111111111111111111111111\n0.111111111111111111111111111111\n', '0.222222222222222222222222222222\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('75', '计算对数', '/dataOJ/1.13.49计算对数', '简单', '3000', '65536', '给定两个正整数a（a>1)和b。可以知道一定存在整数x，使得\n\nx <= logab < x + 1 或者 ax<= b < ax+1\n\n请计算x。\n\n', '两行，第一行是a，第二行是b。每个整数均不超过100位。\n', '一行，即对应的x。输入数据保证x不大于20。\n', '10000\n1000000000001\n', '3\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('76', '垂直直方图', '/dataOJ/1.13.4垂直直方图', '简单', '3000', '65536', '输入4行全部由大写字母组成的文本，输出一个垂直直方图，给出每个字符出现的次数。注意：只用输出字符的出现次数，不用输出空白字符，数字或者标点符号的输出次数。\n\n', '输入包括4行由大写字母组成的文本，每行上字符的数目不超过80个。\n', '输出包括若干行。其中最后一行给出26个大写英文字母，这些字母之间用一个空格隔开。前面的几行包括空格和星号，每个字母出现几次，就在这个字母的上方输出一个星号。注意：输出的第一行不能是空行。\n', 'THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.\nTHIS IS AN EXAMPLE TO TEST FOR YOUR\nHISTOGRAM PROGRAM.\nHELLO!\n', '                            *\n                            *\n        *                   *\n        *                   *     *   *\n        *                   *     *   *\n*       *     *             *     *   *\n*       *     * *     * *   *     * * *\n*       *   * * *     * *   * *   * * * *\n*     * * * * * *     * * * * *   * * * *     * *\n* * * * * * * * * * * * * * * * * * * * * * * * * *\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('77', '数根', '/dataOJ/1.13.50数根', '简单', '3000', '65536', '数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根。如果结果是两位数或者包括更多位的数字，那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。\n\n比如，对于24来说，把2和4相加得到6，由于6是一位数，因此6是24的数根。再比如39，把3和9加起来得到12，由于12不是一位数，因此还得把1和2加起来，最后得到3，这是一个一位数，因此3是39的数根。\n\n', '一个正整数(小于101000)。\n', '一个数字，即输入数字的数根。\n', '24\n', '6\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('78', '古代密码', '/dataOJ/1.13.51古代密码', '简单', '3000', '65536', '古罗马帝国有一个拥有各种部门的强大政府组织。其中一个部门就是保密服务部门。为了保险起见，在省与省之间传递的重要文件中的大写字母是加密的。当时最流行的加密方法是替换和重新排列。\n\n替换方法是将所有出现的字符替换成其它的字符。有些字符会替换成它自己。例如：替换规则可以是将\'A\' 到 \'Y\'替换成它的下一个字符，将\'Z\'替换成 \'A\'，如果原词是 \"VICTORIOUS\" 则它变成 \"WJDUPSJPVT\"。\n\n排列方法改变原来单词中字母的顺序。例如：将顺序例如将顺序 < 2 1 5 4 3 7 6 10 9 8 > 应用到 \"VICTORIOUS\" 上，则得到\"IVOTCIRSUO\"。\n\n人们很快意识到单独应用替换方法或排列方法加密，都是很不保险的。但是如果结合这两种方法，在当时就可以得到非常可靠的加密方法。所以，很多重要信息先使用替换方法加密，再将加密的结果用排列的方法加密。用两种方法结合就可以将\"VICTORIOUS\" 加密成\"JWPUDJSTVP\"。\n\n考古学家最近在一个石台上发现了一些信息。初看起来它们毫无意义，所以有人设想它们可能是用替换和排列的方法被加密了。人们试着解读了石台上的密码，现在他们想检查解读的是否正确。他们需要一个计算机程序来验证，你的任务就是写这个验证程序。\n\n', '输入有两行。第一行是石台上的文字。文字中没有空格，并且只有大写英文字母。第二行是被解读出来的加密前的文字。第二行也是由大写英文字母构成的。\n两行字符数目的长度都不超过100。\n', '如果第二行经过某种加密方法后可以产生第一行的信息，输出 \"YES\"，否则输出\"NO\"。\n', 'JWPUDJSTVP\nVICTORIOUS\n', 'YES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('79', '素数回文数的个数', '/dataOJ/1.13.5素数回文数的个数', '简单', '3000', '65536', '求11到n之间（包括n），既是素数又是回文数的整数有多少个。\n\n', '一个大于11小于1000的整数n。\n', '11到n之间的素数回文数个数。\n', '23\n', '1\n', '回文数指左右对称的数，如：292，333。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('80', '循环数', '/dataOJ/1.13.6循环数', '简单', '3000', '65536', '若一个n位的数字串满足下述条件，则称其是循环数（cyclic）：将这个数字串视为整数（可能带有前导0），并用任意一个 1 到 n 之间（包含1和n）的整数去乘它时, 会得到一个将原数字串首尾相接后，再在某处断开而得到的新数字串所对应的整数。例如，数字 142857 是循环数，因为:\n142857 *1 = 142857\n142857 *2 = 285714\n142857 *3 = 428571\n142857 *4 = 571428\n142857 *5 = 714285\n142857 *6 = 857142。\n\n请写一个程序判断给定的数是否是循环数。\n\n注意：在此题中，输入数字串允许带前导0，且前导0不能被忽略，例如“01”是两位数字串，而“1”是一位数字串。但将数字串转化为整数做乘法运算或比较运算时，可以忽略前导0。\n\n', '一行，一个长度在 2 到 60 位之间的数字串。\n', '一个整数，若输入的数字串是循环数，输出1，否则输出0。\n', '142857\n\n\n', '1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('81', '玛雅历', '/dataOJ/1.13.7玛雅历', '简单', '3000', '65536', '上周末，M.A. Ya教授对古老的玛雅有了一个重大发现。从一个古老的节绳（玛雅人用于记事的工具）中，教授发现玛雅人使用了一个一年有365天的叫做Haab的历法。这个Haab历法拥有19个月，在开始的18个月，一个月有20天，月份的名字分别是pop, no, zip, zotz, tzec, xul, yoxkin, mol, chen, yax, zac, ceh, mac, kankin, muan, pax, koyab, cumhu。这些月份中的日期用0到19表示。Haab历的最后一个月叫做uayet，它只有5天，用0到4表示。玛雅人认为这个日期最少的月份是不吉利的，在这个月法庭不开庭，人们不从事交易，甚至没有人打扫屋中的地板。\n\n因为宗教的原因，玛雅人还使用了另一个历法，在这个历法中年被称为Tzolkin(holly年)，一年被分成13个不同的时期，每个时期有20天，每一天用一个数字和一个单词相组合的形式来表示。使用的数字是1~13，使用的单词共有20个，它们分别是：imix, ik, akbal, kan, chicchan, cimi, manik, lamat, muluk, ok, chuen, eb, ben, ix, mem, cib, caban, eznab, canac, ahau。注意：年中的每一天都有着明确唯一的描述，比如，在一年的开始，日期如下描述： 1 imix, 2 ik, 3 akbal, 4 kan, 5 chicchan, 6 cimi, 7 manik, 8 lamat, 9 muluk, 10 ok, 11 chuen, 12 eb, 13 ben, 1 ix, 2 mem, 3 cib, 4 caban, 5 eznab, 6 canac, 7 ahau, ，8 imix, 9 ik, 10 akbal ……也就是说数字和单词各自独立循环使用。\n\nHaab历和Tzolkin历中的年都用数字0，1，……表示，数字0表示世界的开始。所以第一天被表示成：\nHaab: 0. pop 0\nTzolkin: 1 imix 0\n请帮助M.A. Ya教授写一个程序可以把Haab历转化成Tzolkin历。\n\n', 'Haab历中的数据由如下的方式表示：\n日期. 月份 年数\n\n输入中的第一行表示要转化的Haab历日期的数据量。下面的每一行表示一个日期，年数小于5000。\n', 'Tzolkin历中的数据由如下的方式表示：\n天数字 天名称 年数\n\n第一行表示输出的日期数量。下面的每一行表示一个输入数据中对应的Tzolkin历中的日期。\n', '3\n10. zac 0\n0. pop 0\n10. zac 1995\n', '3\n3 chuen 0\n1 imix 0\n9 cimi 2801\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('82', '特殊日历计算', '/dataOJ/1.13.8特殊日历计算', '简单', '3000', '65536', '有一种特殊的日历法，它的一天和我们现在用的日历法的一天是一样长的。它每天有10个小时，每个小时有100分钟，每分钟有100秒。10天算一周，10周算一个月，10个月算一年。现在要你编写一个程序，将我们常用的日历法的日期转换成这种特殊的日历表示法。这种日历法的时、分、秒是从0开始计数的。日、月从1开始计数，年从0开始计数。秒数为整数。假设 0:0:0 1.1.2000 等同于特殊日历法的 0:0:0 1.1.0。\n', '第一行是一个正整数 N ,表明下面有 N 组输入。每组输入有一行，格式如下：hour:minute:second day.month.year\n表示常规的日期。日期总是合法的。2000 <= year <= 50000。\n', '每组输入要求输出一行。格式如下：mhour:mmin:msec mday.mmonth.myear 是输入日期的特殊日历表示方法。\n', '7\n0:0:0 1.1.2000\n10:10:10 1.3.2001\n0:12:13 1.3.2400\n23:59:59 31.12.2001\n0:0:1 20.7.7478\n0:20:20 21.7.7478\n15:54:44 2.10.20749\n', '0:0:0 1.1.0\n4:23:72 26.5.0\n0:8:48 58.2.146\n9:99:98 31.8.0\n0:0:1 100.10.2000\n0:14:12 1.1.2001\n6:63:0 7.3.6848\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('83', '大整数乘法', '/dataOJ/1.13.9大整数乘法', '简单', '3000', '65536', '求两个不超过200位的非负整数的积。\n\n', '有两行，每行是一个不超过200位的非负整数，没有多余的前导0。\n', '一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。\n', '12345678900\n98765432100\n', '1219326311126352690000\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('84', 'Hello, World!的大小', '/dataOJ/1.2.10Hello, World!的大小', '简单', '3000', '65536', '还记得在上一章里，我们曾经输出过的“Hello, World!”吗？\n\n它虽然不是本章所涉及的基本数据类型的数据，但我们同样可以用sizeof函数获得它所占用的空间大小。\n\n请编程求出它的大小，看看跟你设想的是否一样？\n\n', '无。\n', '一个整数，即“Hello, World!”的大小。\n', '（无）\n', '（不提供）\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('85', '整型数据类型存储空间大小', '/dataOJ/1.2.1整型数据类型存储空间大小', '简单', '3000', '65536', '分别定义int，short类型的变量各一个，并依次输出它们的存储空间大小（单位：字节）。\n\n', '无。\n', '一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。\n', '（无）\n', '（不提供）\n', '使用sizeof函数可以得到一个特定变量的存储空间大小。例如：对于int型变量x，sizeof(x)的值为4，即x的存储空间为4字节。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('86', '浮点型数据类型存储空间大小', '/dataOJ/1.2.2浮点型数据类型存储空间大小', '简单', '3000', '65536', '分别定义float，double类型的变量各一个，并依次输出它们的存储空间大小（单位：字节）。\n\n\n\n', '无。\n', '一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。\n', '（无）\n', '（不提供）\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('87', '其他基本数据类型存储空间大小', '/dataOJ/1.2.3其他基本数据类型存储空间大小', '简单', '3000', '65536', '分别定义bool，char类型的变量各一个，并依次输出它们的存储空间大小（单位：字节）。\n\n', '无。\n', '一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。\n', '（无）\n', '（不提供）\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('88', '类型转换1', '/dataOJ/1.2.4类型转换1', '简单', '3000', '65536', '有两个变量a和b，在执行了如下代码后：\n\na = 32768;\nb = a;\nprintf(\"%d %d\\n\", a, b);\n输出两个数：32768 -32768\n\n请问a和b分别是以下哪种类型？\n\nA. bool   B. char   C. short   D. int   E. float   F. double\n\n', '无。\n', '一行，包含两个大写字母，分别代表变量a和b的类型标号。中间用一个空格隔开。\n', '无\n', 'A B\n// 仅作格式示例，非正确答案\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('89', '类型转换2', '/dataOJ/1.2.5类型转换2', '简单', '3000', '65536', '有两个变量a和b，在执行了如下代码后：\n\na = 1.000000001;\nb = a;\nprintf(\"%.9f %.9f\\n\", a, b);\n输出两个数：1.000000001 1.000000000\n\n请问a和b分别是以下哪种类型？\n\nA. bool   B. char   C. short   D. int   E. float   F. double\n\n\n\n', '无。\n', '一行，包含两个大写字母，分别代表变量a和b的类型标号。中间用一个空格隔开。\n', '无\n', 'A B\n// 仅作格式示例，非正确答案\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('90', '浮点数向零舍入', '/dataOJ/1.2.6浮点数向零舍入', '简单', '3000', '65536', '输入一个单精度浮点数，将其向零舍入到整数。\n\n说明：向零舍入的含义是，正数向下舍入，负数向上舍入。\n\n提示：可以使用强制类型转换来实现。\n\n', '一个单精度浮点数。\n', '一个整数，即向零舍入到整数的结果。\n', '2.3\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('91', '打印ASCII码', '/dataOJ/1.2.7打印ASCII码', '简单', '3000', '65536', '输入一个除空格以外的可见字符（保证在函数scanf中可使用格式说明符%c读入），输出其ASCII码。\n\n', '一个除空格以外的可见字符。\n', '一个十进制整数，即该字符的ASCII码。\n', 'A\n', '65\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('92', '整型与布尔型的转换', '/dataOJ/1.2.9整型与布尔型的转换', '简单', '3000', '65536', '将一个整型变量的值赋给一个布尔型变量，再将这个布尔型变量的值赋给一个整型变量，得到的值是多少？\n\n', '一个整型范围内的整数，即初始时整型变量的值。\n', '一个整数，经过上述过程后得到的结果。\n', '3\n', '1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('93', '计算并联电阻的阻值', '/dataOJ/1.3.10计算并联电阻的阻值', '简单', '3000', '65536', '对于阻值为r1和r2的电阻，其并联电阻阻值公式计算如下：\n\nR = 1/(1/r1 + 1/r2)\n\n', '两个电阻阻抗大小，浮点型，以一个空格分开。\n', '并联之后的阻抗大小，结果保留小数点后2位\n', '1 2\n', '0.67\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('94', '计算浮点数相除的余数', '/dataOJ/1.3.11计算浮点数相除的余数', '简单', '3000', '65536', '计算两个双精度浮点数a和b的相除的余数，a和b都是正数的。这里余数（r）的定义是：a = k * b + r，其中 k是整数， 0 <= r < b。\n\n', '输入仅一行，包括两个双精度浮点数a和b。\n', '输出也仅一行，a÷b的余数\n', '73.263 0.9973\n', '0.4601\n', '注意：输出时小数尾部没有多余的0，可以用下面这种格式：\ndouble x;\nx = 1.33;\nprintf(\"%g\", x);\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('95', '大象喝水', '/dataOJ/1.3.14大象喝水', '简单', '3000', '65536', '一只大象口渴了，要喝20升水才能解渴，但现在只有一个深h厘米，底面半径为r厘米的小圆桶(h和r都是整数)。问大象至少要喝多少桶水才会解渴。\n\n', '输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深h和底面半径r，单位都是厘米。\n', '输出一行，包含一个整数，表示大象至少要喝水的桶数。\n', '23 11\n', '3\n', '如果一个圆桶的深为h厘米，底面半径为r厘米，那么它最多能装Pi * r * r * h立方厘米的水。(设Pi=3.14159)\n1升 = 1000毫升\n1毫升 = 1 立方厘米\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('96', '苹果和虫子', '/dataOJ/1.3.15苹果和虫子', '简单', '3000', '65536', '你买了一箱n个苹果，很不幸的是买完时箱子里混进了一条虫子。虫子每x小时能吃掉一个苹果，假设虫子在吃完一个苹果之前不会吃另一个，那么经过y小时你还有多少个完整的苹果？\n\n', '输入仅一行，包括n，x和y（均为整数）。输入数据保证y <= n * x。\n', '输出也仅一行，剩下的苹果个数\n', '10 4 9\n', '7\n', '注意：是要求完整的苹果数。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('97', '计算线段长度', '/dataOJ/1.3.16计算线段长度', '简单', '3000', '65536', '已知线段的两个端点的坐标A（Xa,Ya），B（Xb，Yb），求线段AB的长度。\n\n', '共两行。\n第一行是两个实数Xa，Ya，即A的坐标。\n第二行是两个实数Xb，Yb，即B的坐标。\n输入中所有实数的绝对值均不超过10000。\n', '一个实数，即线段AB的长度，保留到小数点后3位。\n', '1 1\n2 2\n', '1.414\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('98', '计算三角形面积', '/dataOJ/1.3.17计算三角形面积', '简单', '3000', '65536', '平面上有一个三角形，它的三个顶点坐标分别为(x1, y1), (x2, y2), (x3, y3)，那么请问这个三角形的面积是多少。\n\n', '输入仅一行，包括6个单精度浮点数，分别对应x1, y1, x2, y2, x3, y3。\n', '输出也是一行，输出三角形的面积，精确到小数点后两位。\n', '0 0 4 0 0 3\n', '6.00\n', '海伦公式\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('99', '等差数列末项计算', '/dataOJ/1.3.18等差数列末项计算', '简单', '3000', '65536', '给出一个等差数列的前两项a1，a2，求第n项是多少。\n\n', '一行，包含三个整数a1，a​2，n。-100 <= a1,a​2 <= 100，0 < n <= 1000。\n', '一个整数，即第n项的值。\n', '1 4 100\n', '298\n来源\n《奥数典型题举一反三（小学五年级）》 (ISBN 978-7-5445-2882-5) 第一章 第一讲 习题1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('100', 'AB问题', '/dataOJ/1.3.19AB问题', '简单', '3000', '65536', '输入两个正整数A和B，求A*B。\n\n', '一行，包含两个正整数A和B，中间用单个空格隔开。1 <= A,B <= 50000。\n', '一个整数，即A*B的值。\n', '3 4\n', '12\n', '注意乘积的范围和数据类型的选择\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('101', '计算2的幂', '/dataOJ/1.3.20计算2的幂', '简单', '3000', '65536', '给定非负整数n，求2n。\n\n', '一个整数n。0 <= n < 31。\n', '一个整数，即2的n次方。\n', '3\n', '8\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('102', '计算(a+b)c的值', '/dataOJ/1.3.2计算(a+b)c的值', '简单', '3000', '65536', '给定3个整数a、b、c，计算表达式(a+b)*c的值。\n\n', '输入仅一行，包括三个整数a、b、c, 数与数之间以一个空格分开。\n(－10,000 < a,b,c < 10,000)\n', '输出一行，即表达式的值\n', '2 3 5\n', '25\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('103', '计算(a+b) c的值', '/dataOJ/1.3.3计算(a+b) c的值', '简单', '3000', '65536', '给定3个整数a、b、c，计算表达式(a+b)/c的值，/是整除运算。\n\n', '输入仅一行，包括三个整数a、b、c, 数与数之间以一个空格分开。(－10,000 < a,b,c < 10,000, c不等于0)\n', '输出一行，即表达式的值。\n', '1 1 3\n', '0\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('104', '带余除法', '/dataOJ/1.3.4带余除法', '简单', '3000', '65536', '给定被除数和除数，求整数商及余数。\n\n此题中请使用默认的整除和取余运算，无需对结果进行任何特殊处理。看看程序运行结果与数学上的定义有什么不同？\n\n', '一行，包含两个整数，依次为被除数和除数（除数非零），中间用一个空格隔开。\n', '一行，包含两个整数，依次为整数商和余数，中间用一个空格隔开。\n', '10 3\n', '3 1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('105', '计算分数的浮点数值', '/dataOJ/1.3.5计算分数的浮点数值', '简单', '3000', '65536', '两个整数a和b分别作为分子和分母，既分数 a/b ，求它的浮点数值（双精度浮点数，保留小数点后9位）\n\n', '输入仅一行，包括两个整数a和b（b不为0）\n', '输出也仅一行，分数 a/b 的浮点数值（双精度浮点数，保留小数点后9位）\n', '5 7\n', '0.714285714\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('106', '甲流疫情死亡率', '/dataOJ/1.3.6甲流疫情死亡率', '简单', '3000', '65536', '甲流并不可怕，在中国，它的死亡率并不是很高。请根据截止2009年12月22日各省报告的甲流确诊数和死亡数，计算甲流在各省的死亡率。\n\n', '输入仅一行，有两个整数，第一个为确诊数，第二个为死亡数。\n', '输出仅一行，甲流死亡率，以百分数形式输出，精确到小数点后3位。\n', '10433 60\n', '0.575%\n', '输出%可以使用printf(“%%”);\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('107', '计算多项式的值', '/dataOJ/1.3.7计算多项式的值', '简单', '3000', '65536', '对于多项式f(x) = ax3 + bx2 + cx + d 和给定的a, b, c, d, x，计算f(x)的值。\n\n', '输入仅一行，包含5个实数，分别是x，及参数a、b、c、d的值，每个数都是绝对值不超过100的双精度浮点数。数与数之间以一个空格分开。\n', '输出一个实数，即f(x)的值，保留到小数点后7位。\n', '2.31 1.2 2 2 3\n', '33.0838692\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('108', '与圆相关的计算', '/dataOJ/1.3.9与圆相关的计算', '简单', '3000', '65536', '给出圆的半径，求圆的直径、周长和面积。\n\n', '输入包含一个实数r（0 < r <= 10,000），表示圆的半径。\n', '输出一行，包含三个数，分别表示圆的直径、周长、面积，数与数之间以一个空格分开，每个数保留小数点后4位。\n', '3.0\n', '6.0000 18.8495 28.2743\n', '如果圆的半径是r，那么圆的直径、周长、面积分别是2*r、2 * pi * r、pi * r * r，其中约定pi＝3.14159。\n可以使用printf(\"%.4lf\", ...)实现保留小数点后4位。\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('109', '有一门课不及格的学生', '/dataOJ/1.4.10有一门课不及格的学生', '简单', '3000', '65536', '给出一名学生的语文和数学成绩，判断他是否恰好有一门课不及格（成绩小于60分）。\n\n', '一行，包含两个在0到100之间的整数，分别是该生的语文成绩和数学成绩。\n', '若该生恰好有一门课不及格，输出1；否则输出0。\n', '50 80\n', '1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('110', '晶晶赴约会', '/dataOJ/1.4.11晶晶赴约会', '简单', '3000', '65536', '晶晶的朋友贝贝约晶晶下周一起去看展览，但晶晶每周的1、3、5有课必须上课，请帮晶晶判断她能否接受贝贝的邀请，如果能输出YES；如果不能则输出NO。\n\n', '输入有一行，贝贝邀请晶晶去看展览的日期，用数字1到7表示从星期一到星期日。\n', '输出有一行，如果晶晶可以接受贝贝的邀请，输出YES，否则，输出NO。注意YES和NO都是大写字母！\n', '2\n', 'YES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('111', '骑车与走路', '/dataOJ/1.4.12骑车与走路', '简单', '3000', '65536', '在北大校园里,没有自行车,上课办事会很不方便.但实际上,并非去办任何事情都是骑车快,因为骑车总要找车、开锁、停车、锁车等,这要耽误一些时间.假设找到自行车,开锁并车上自行车的时间为27秒;停车锁车的时间为23秒;步行每秒行走1.2米,骑车每秒行走3.0米。请判断走不同的距离去办事,是骑车快还是走路快。\n\n', '输入一行，包含一个整数，表示一次办事要行走的距离,单位为米。\n', '输出一行,如果骑车快,输出一行\"Bike\";如果走路快,输出一行\"Walk\";如果一样快,输出一行\"All\"。\n', '120\n', 'Bike\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('112', '分段函数', '/dataOJ/1.4.13分段函数', '简单', '3000', '65536', '编写程序，计算下列分段函数y=f(x)的值。\n\ny=-x+2.5; 0 <= x < 5\n\ny=2-1.5(x-3)(x-3); 5 <= x < 10\n\ny=x/2-1.5; 10 <= x < 20\n\n', '一个浮点数N,0 <= N < 20\n', '输出N对应的分段函数值：f(N)。结果保留到小数点后三位。\n', '1.0\n', '1.500\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('113', '计算邮资', '/dataOJ/1.4.14计算邮资', '简单', '3000', '65536', '根据邮件的重量和用户是否选择加急计算邮费。计算规则：重量在1000克以内(包括1000克), 基本费8元。超过1000克的部分，每500克加收超重费4元，不足500克部分按500克计算；如果用户选择加急，多收5元。\n\n', '输入一行，包含整数和一个字符，以一个空格分开，分别表示重量（单位为克）和是否加急。如果字符是y，说明选择加急；如果字符是n，说明不加急。\n', '输出一行，包含一个整数，表示邮费。\n', '1200 y\n', '17\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('114', '三角形判断', '/dataOJ/1.4.16三角形判断', '简单', '3000', '65536', '给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。\n\n', '输入共一行，包含三个正整数，分别表示三条线段的长度，数与数之间以一个空格分开。\n', '如果能构成三角形，则输出“yes” ，否则输出“no”。\n', '3 4 5\n', 'yes\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('115', '点和正方形的关系', '/dataOJ/1.4.18点和正方形的关系', '简单', '3000', '65536', '有一个正方形，四个角的坐标（x,y)分别是（1，-1），（1，1），（-1，-1），（-1，1），x是横轴，y是纵轴。写一个程序，判断一个给定的点是否在这个正方形内（包括正方形边界）。\n\n', '输入一行，包括两个整数x、y，以一个空格分开，表示坐标(x,y)。\n', '输出一行，如果点在正方形内，则输出yes，否则输出no。\n', '1 1\n', 'yes\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('116', '判断数正负', '/dataOJ/1.4.1判断数正负', '简单', '3000', '65536', '给定一个整数N，判断其正负。\n\n\n\n', '一个整数N(-109 <= N <= 109)\n', '如果N > 0, 输出positive;\n如果N = 0, 输出zero;\n如果N < 0, 输出negative\n', '1\n', 'positive\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('117', '输出绝对值', '/dataOJ/1.4.2输出绝对值', '简单', '3000', '65536', '输入一个浮点数，输出这个浮点数的绝对值。\n\n', '输入一个浮点数，其绝对值不超过10000。\n', '输出这个浮点数的绝对值，保留到小数点后两位。\n', '-3.14\n', '3.14\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('118', '奇偶数判断', '/dataOJ/1.4.3奇偶数判断', '简单', '3000', '65536', '给定一个整数，判断该数是奇数还是偶数。\n\n', '输入仅一行，一个大于零的正整数n。\n', '输出仅一行，如果n是奇数，输出odd；如果n是偶数，输出even。\n', '5\n', 'odd\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('119', '奇偶ASCII值判断', '/dataOJ/1.4.4奇偶ASCII值判断', '简单', '3000', '65536', '任意输入一个字符，判断其ASCII是否是奇数，若是，输出YES，否则，输出NO\n例如，字符A的ASCII值是65，则输出YES，若输入字符B(ASCII值是66)，则输出NO\n\n', '输入一个字符\n', '如果其ASCII值为奇数，则输出YES，否则，输出NO\n', 'A\n', 'YES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('120', '整数大小比较', '/dataOJ/1.4.5整数大小比较', '简单', '3000', '65536', '输入两个整数，比较它们的大小。\n\n', '一行，包含两个整数x和y，中间用单个空格隔开。\n0 <= x < 2^32, -2^31 <= y < 2^31。\n', '一个字符。\n若x > y，输出 > ；\n若x = y，输出 = ；\n若x < y，输出 < ；\n', '1000 100\n', '>\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('121', '判断是否为两位数', '/dataOJ/1.4.6判断是否为两位数', '简单', '3000', '65536', '判断一个正整数是否是两位数（即大于等于10且小于等于99）。\n\n', '一个正整数，不超过1000。\n', '一行。若该正整数是两位数，输出1，否则输出0。\n', '54\n', '1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('122', '收集瓶盖赢大奖', '/dataOJ/1.4.7收集瓶盖赢大奖', '简单', '3000', '65536', '某饮料公司最近推出了一个“收集瓶盖赢大奖”的活动：如果你拥有10个印有“幸运”、或20个印有“鼓励”的瓶盖，就可以兑换一个神秘大奖。\n\n现分别给出你拥有的印有“幸运”和“鼓励”的瓶盖数，判断是否可以去兑换大奖。\n\n', '一行，包含两个整数，分别是印有“幸运”和“鼓励”的瓶盖数，用一个空格隔开。\n', '一行。若可以兑换大奖，输出1，否则输出0。\n', '11 19\n', '1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('123', '判断能否被3，5，7整除', '/dataOJ/1.4.9判断能否被3，5，7整除', '简单', '3000', '65536', '给定一个整数，判断它能否被3，5，7整除，并输出以下信息：\n1、能同时被3，5，7整除（直接输出3 5 7，每个数中间一个空格）；\n2、只能被其中两个数整除（输出两个数，小的在前，大的在后。例如：3 5或者 3 7或者5 7,中间用空格分隔）；\n3、只能被其中一个数整除（输出这个除数）；\n4、不能被任何数整除，输出小写字符‘n’,不包括单引号。\n\n', '输入一行，包括一个整数。\n', '输出一行，按照描述要求给出整数被3，5，7整除的情况。\n', '105\n', '3 5 7\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('124', '满足条件的数累加', '/dataOJ/1.5.10满足条件的数累加', '简单', '3000', '65536', '将正整数 m 和 n 之间（包括 m 和 n）能被 17 整除的数累加。其中，0 < m < n < 1000。\n\n', '一行，包含两个整数m和n，其间，以一个空格间隔。\n', '输出一行，包行一个整数，表示累加的结果。\n', '50 85\n', '204\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('125', '整数的个数', '/dataOJ/1.5.11整数的个数', '简单', '3000', '65536', '给定k（1\n< k < 100）个正整数，其中每个数都是大于等于1，小于等于10的数。写程序计算给定的k个正整数中，1，5和10出现的次数。\n\n', '输入有两行：第一行包含一个正整数k，第二行包含k个正整数，每两个正整数用一个空格分开。\n', '输出有三行，第一行为1出现的次数，，第二行为5出现的次数，第三行为10出现的次数。\n', '5\n1 5 8 10 5 \n', '1\n2\n1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('126', '与指定数字相同的数的个数', '/dataOJ/1.5.12与指定数字相同的数的个数', '简单', '3000', '65536', '输出一个整数序列中与指定数字相同的数的个数。\n\n', '输入包含2行：\n第1行为N和m，表示整数序列的长度(N <= 100)和指定的数字， 中间用一个空格分开；\n第2行为N个整数，整数之间以一个空格分开。\n', '输出为N个数中与m相同的数的个数。\n', '3 2\n2 3 2\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('127', '乘方计算', '/dataOJ/1.5.13乘方计算', '简单', '3000', '65536', '给出一个整数a和一个正整数n，求乘方an。\n\n', '一行，包含两个整数a和n。-1000000 <= a <= 1000000，1 <= n <= 10000。\n', '一个整数，即乘方结果。题目保证最终结果的绝对值不超过1000000。\n', '2 3\n', '8\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('128', '人口增长问题', '/dataOJ/1.5.14人口增长问题', '简单', '3000', '65536', '我国现有x亿人口，按照每年0.1%的增长速度，n年后将有多少人？\n\n', '一行，包含两个整数x和n，分别是人口基数和年数，以单个空格分隔。\n', '输出最后的人口数，以亿为单位，保留到小数点后四位。1 <= x <= 100, 1 <= n <= 100。\n', '13 10\n', '13.1306\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('129', '银行利息', '/dataOJ/1.5.15银行利息', '简单', '3000', '65536', '农夫约翰在去年赚了一大笔钱！他想要把这些钱用于投资，并对自己能得到多少收益感到好奇。已知投资的复合年利率为R（0到20之间的整数）。约翰现有总值为M的钱（100到1,000,000之间的整数）。他清楚地知道自己要投资Y年（范围0到400）。请帮助他计算最终他会有多少钱，并输出它的整数部分。数据保证输出结果在32位有符号整数范围内。\n\n', '一行包含三个整数R，M，Y，相邻两个整数之间用单个空格隔开。\n', '一个整数，即约翰最终拥有多少钱（整数部分）。\n', '5 5000 4\n', '6077\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('130', '买房子', '/dataOJ/1.5.16买房子', '简单', '3000', '65536', '某程序员开始工作，年薪N万，他希望在中关村公馆买一套60平米的房子，现在价格是200万，假设房子价格以每年百分之K增长，并且该程序员未来年薪不变，且不吃不喝，不用交税，每年所得N万全都积攒起来，问第几年能够买下这套房子？（第一年年薪N万，房价200万）\n\n', '一行，包含两个正整数N（10 <= N <= 50）, K（1 <= K <= 20），中间用单个空格隔开。\n', '如果在第20年或者之前就能买下这套房子，则输出一个整数M，表示最早需要在第M年能买下，否则输出Impossible。\n', '50 10\n', '8\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('131', '菲波那契数列', '/dataOJ/1.5.17菲波那契数列', '简单', '3000', '65536', '菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。\n给出一个正整数k，要求菲波那契数列中第k个数是多少。\n\n', '输入一行，包含一个正整数k。（1 <= k <= 46）\n', '输出一行，包含一个正整数，表示菲波那契数列中第k个数的大小\n', '19\n', '4181\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('132', '鸡尾酒疗法', '/dataOJ/1.5.18鸡尾酒疗法', '简单', '3000', '65536', '鸡尾酒疗法，原指“高效抗逆转录病毒治疗”（HAART），由美籍华裔科学家何大一于1996年提出，是通过三种或三种以上的抗病毒药物联合使用来治疗艾 滋病。该疗法的应用可以减少单一用药产生的抗药性，最大限度地抑制病毒的复制，使被破坏的机体免疫功能部分甚至全部恢复，从而延缓病程进展，延长患者生 命，提高生活质量。人们在鸡尾酒疗法的基础上又提出了很多种改进的疗法。为了验证这些治疗方法是否在疗效上比鸡尾酒疗法更好，可用通过临床对照实验的方式 进行。假设鸡尾酒疗法的有效率为x，新疗法的有效率为y，如果y-x大于5%，则效果更好，如果x-y大于5%，则效果更差，否则称为效果差不多。下面给 出n组临床对照实验，其中第一组采用鸡尾酒疗法，其他n-1组为各种不同的改进疗法。请写程序判定各种改进疗法效果如何。\n\n', '第一行为整数n（ 1 < n <= 20）；\n其余n行每行两个整数，第一个整数是临床实验的总病例数(小于等于10000)，第二个疗效有效的病例数。\n这n行数据中，第一行为鸡尾酒疗法的数据，其余各行为各种改进疗法的数据。\n', '有n-1行输出，分别表示对应改进疗法的效果：\n如果效果更好，输出better；如果效果更差，输出worse；否则输出same\n', '5\n125 99\n112 89\n145 99\n99 97\n123 98\n', 'same\nworse\nbetter\nsame\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('133', '救援', '/dataOJ/1.5.19救援', '简单', '3000', '65536', '救生船从大本营出发，营救若干屋顶上的人回到大本营，屋顶数目以及每个屋顶的坐标\n和人数都将由输入决定，求出所有人都到达大本营并登陆所用的时间。\n\n在直角坐标系的原点是大本营，救生船每次从大本营出发，救了人之后将人送回大本营。坐标系中的点代表屋顶，每个屋顶由其位置坐标和其上的人数表 示。救生船每次从大本营出发，以速度50 米/分钟驶向下一个屋顶，达到一个屋顶后，救下其上的所有人，每人上船1 分钟，船原路返回，达到大本营，每人下船0.5 分钟。假设原点与任意一个屋顶的连线不穿过其它屋顶。\n\n', '第一行，一个整数，表示屋顶数n。\n接下来依次有n 行输入，每一行上包含两个表示屋顶相对于大本营的平面坐标位置的实数（单位是米）、一个表示人数的整数，数之间以一个空格分\n开。\n', '一行，救援需要的总时间，精确到分钟 (向上取整)。\n', '1\n30 40 3\n', '7\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('134', '求平均年龄', '/dataOJ/1.5.1求平均年龄', '简单', '3000', '65536', '班上有学生若干名，给出每名学生的年龄（整数），求班上所有学生的平均年龄，保留到小数点后两位。\n\n', '第一行有一个整数n（1<= n <= 100），表示学生的人数。其后n行每行有1个整数，表示每个学生的年龄，取值为15到25。\n', '输出一行，该行包含一个浮点数，为要求的平均年龄，保留到小数点后两位。\n', '2\n18\n17\n', '17.50\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('135', '药房管理', '/dataOJ/1.5.23药房管理', '简单', '3000', '65536', '   随着信息技术的蓬勃发展，医疗信息化已经成为医院建设中必不可少的一部分。计算机可以很好地辅助医院管理医生信息、病人信息、药品信息等海量数据，使工作人员能够从这些机械的工作中解放出来，将更多精力投入真正的医疗过程中，从而极大地提高了医院整体的工作效率。\n    对药品的管理是其中的一项重要内容。现在药房的管理员希望使用计算机来帮助他管理。假设对于任意一种药品，每天开始工作时的库存总量已 知，并且一天之内不会通过进货的方式增加。每天会有很多病人前来取药，每个病人希望取走不同数量的药品。如果病人需要的数量超过了当时的库存量，药房会拒 绝该病人的请求。管理员希望知道每天会有多少病人没有取上药。\n\n', '共3行\n第一行是每天开始时的药品总量m\n第二行是这一天取药的人数n（0 < n <= 100）\n第三行共有n个数，分别记录了每个病人希望取走的药品数量（按照时间先后的顺序），两数之间以空格分隔\n', '只有1行，为这一天没有取上药品的人数。\n', '30\n6\n10 5 20 6 7 8\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('136', '正常血压', '/dataOJ/1.5.24正常血压', '简单', '3000', '65536', '监护室每小时测量一次病人的血压，若收缩压在90 - 140之间并且舒张压在60 - 90之间（包含端点值）则称之为正常，现给出某病人若干次测量的血压值，计算病人保持正常血压的最长小时数。\n\n', '第一行为一个正整数n，n < 100\n其后有n行，每行2个正整数，分别为一次测量的收缩压和舒张压，中间以一个空格分隔。\n', '输出仅一行，血压连续正常的最长小时数。\n', '4\n100 80\n90 50\n120 60\n140 90\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('137', '求特殊自然数', '/dataOJ/1.5.25求特殊自然数', '简单', '3000', '65536', '一个十进制自然数,它的七进制与九进制表示都是三位数，且七进制与九进制的三位数码表示顺序正好相反。编程求此自然数,并输出显示。\n\n', '无。\n', '三行：\n第一行是此自然数的十进制表示；\n第二行是此自然数的七进制表示；\n第三行是此自然数的九进制表示。\n', '（无）\n', '（不提供）\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('138', '统计满足条件的4位数个数', '/dataOJ/1.5.26统计满足条件的4位数个数', '简单', '3000', '65536', '给定若干个四位数，求出其中满足以下条件的数的个数：\n\n个位数上的数字减去千位数上的数字，再减去百位数上的数字， 再减去十位数上的数字的结果大于零。\n\n', '输入为两行，第一行为四位数的个数n，第二行为n个的四位数，数与数之间以一个空格分开。(n <= 100)\n', '输出为一行，包含一个整数，表示满足条件的四位数的个数。\n', '5\n1234 1349 6119 2123 5017\n', '3\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('139', '级数求和', '/dataOJ/1.5.27级数求和', '简单', '3000', '65536', '已知：Sn= 1＋1／2＋1／3＋…＋1／n。显然对于任意一个整数K，当n足够大的时候，Sn大于K。\n\n现给出一个整数K（1<=k<=15），要求计算出一个最小的n；使得Sn＞K。\n\n', '一个整数K。\n', '一个整数n。\n', '1\n', '2\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('140', '分离整数的各个数位', '/dataOJ/1.5.28分离整数的各个数位', '简单', '3000', '65536', '给定一个整数，要求从个位开始分离出它的每一位数字。\n\n', '输入一个整数，整数在1到100000000之间。\n', '从个位开始按照从低位到高位的顺序依次输出每一位数字。数字之间以一个空格分开。\n', '123\n', '3 2 1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('141', '数字反转', '/dataOJ/1.5.29数字反转', '简单', '3000', '65536', '给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。\n\n', '输入共 1 行，一个整数N。\n\n-1,000,000,000 ≤ N≤ 1,000,000,000。\n', '输出共 1 行，一个整数，表示反转后的新数。\n', '样例 #1：\n123\n\n样例 #2：\n-380\n', '样例 #1：\n321\n\n样例 #2：\n-83\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('142', '财务管理', '/dataOJ/1.5.2财务管理', '简单', '3000', '65536', 'Larry今年毕业并找到了一份工作。他赚很多钱，但似乎总是不够。Larry认为他需要控制他的投资以解决自己的财务问题。Larry拿到了自己的银行账户详单，想看看自己有多少钱。请帮助Larry写一个程序，通过过去12个月中每月的月末结余，计算平均结余。\n\n', '输入包含12行，每行包含一个数，为某个月的结余。每个数都是不大于1,000,000的正数，保留两位小数，省略\"$\"符。\n', '输出一个数，为这12个月的平均月末结余，保留到小数点后第二位，并在最前面加一个\"$\"符。\n', '100.00\n489.12\n12454.12\n1234.10\n823.05\n109.20\n5.27\n1542.25\n839.18\n83.99\n1295.01\n1.75\n', '$1581.42\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('143', '含k个3的数', '/dataOJ/1.5.30含k个3的数', '简单', '3000', '65536', '输入两个正整数 m 和 k，其中1 < m < 100000，1 < k < 5 ，判断 m 能否被19整除，且恰好含有k个3，如果满足条件，则输出YES，否则，输出NO。\n\n例如，输入：\n43833 3\n满足条件，输出YES。\n\n如果输入：\n39331 3\n尽管有3个3，但不能被19整除，也不满足条件，应输出NO。\n\n', 'm 和 k 的值，中间用单个空格间隔。\n', '满足条件时输出 YES，不满足时输出 NO。\n', '43833 3\n', 'YES\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('144', '开关灯', '/dataOJ/1.5.31开关灯', '简单', '3000', '65536', '假设有N盏灯(N为不大于5000的正整数)，从1到N按顺序依次编号，初始时全部处于开启状态；有M个人(M为不大于N的正整数)也从1到M依次编号。\n\n第一个人（1号）将灯全部关闭，第二个人（2号）将编号为2的倍数的灯打开，第三个人（3号）将编号为3的倍数的灯做相反处理（即，将打开的灯关闭，将关闭的灯打开）。依照编号递增顺序，以后的人都和3号一样，将凡是自己编号倍数的灯做相反处理。\n\n请问：当第M个人操作之后，哪几盏灯是关闭的，按从小到大输出其编号，其间用逗号间隔。\n\n', '输入正整数N和M，以单个空格隔开。\n', '顺次输出关闭的灯的编号，其间用逗号间隔。\n', '10 10\n', '1,4,9\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('145', '求分数序列和', '/dataOJ/1.5.32求分数序列和', '简单', '3000', '65536', '有一个分数序列 q1/p1,q2/p2,q3/p3,q4/p4,q5/p5,.... ,其中qi+1= qi+ pi, pi+1=qi, p1= 1, q1= 2。比如这个序列前6项分别是2/1,3/2,5/3,8/5,13/8,21/13。求这个分数序列的前n项之和。\n\n', '输入有一行，包含一个正整数n(n <= 30)。\n', '输出有一行，包含一个浮点数，表示分数序列前n项的和，精确到小数点后4位。\n', '2\n', '3.5000\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('146', '计算分数加减表达式的值', '/dataOJ/1.5.33计算分数加减表达式的值', '简单', '3000', '65536', '编写程序，输入n的值，求 1/1 - 1/2 + 1/3 - 1/4 + 1/5 - 1/6 + 1/7 - 1/8 + ... + (-1)n-1·1/n 的值。\n\n', '输入一个正整数n。1 <= n <= 1000。\n', '输出一个实数，为表达式的值，保留到小数点后四位。\n', '2\n', '0.5000\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('147', '求出e的值', '/dataOJ/1.5.35求出e的值', '简单', '3000', '65536', '利用公式e = 1 + 1/1! + 1/2! + 1/3! + ... + 1/n! 求e 。\n', '输入只有一行，该行包含一个整数n（2<=n<=15），表示计算e时累加到1/n！。\n', '输出只有一行，该行包含计算出来的e的值，要求打印小数点后10位。\n', '10\n', '2.7182818011\n', '1、e以及n!用double表示\n\n2、要输出浮点数、双精度数小数点后10位数字，可以用下面这种形式：\n\nprintf(\"%.10f\", num);\n', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('148', '计算多项式的值', '/dataOJ/1.5.36计算多项式的值', '简单', '3000', '65536', '假定多项式的形式为xn+xn-1+…+x2+x+1，请计算给定单精度浮点数x和正整数n值的情况下这个多项式的值。\n\n', '输入仅一行，包括x和n，用单个空格隔开。x在double范围内，n <= 1000000。\n', '输出一个实数，即多项式的值，精确到小数点后两位。保证最终结果在double范围内。\n', '2.0 4\n', '31.00\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('149', '雇佣兵', '/dataOJ/1.5.37雇佣兵', '简单', '3000', '65536', '雇佣兵的体力最大值为M，初始体力值为0、战斗力为N、拥有X个能量元素。\n\n当雇佣兵的体力值恰好为M时，才可以参加一个为期M天的战斗期，战斗期结束体力值将为0。在同一个战斗期内，雇佣兵每连续战斗n天，战斗力就会上升1点，n为当前战斗期开始时的战斗力。\n\n一个战斗期结束后，雇佣兵需要用若干个能量元素使其体力恢复到最大值M，从而参加下一个战斗期。每个能量元素恢复的体力值不超过当前的战斗力。每个能量元素只能使用一次。\n\n请问：雇佣兵的战斗力最大可以到达多少。\n\n', '一行包括三个整数M、N、X，相邻两个整数之间用单个空格隔开。M、N、X均为不超过10000的正整数。\n', '输出一个整数，为雇佣兵的最大战斗力。\n', '5 2 10\n', '6\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('150', '计算多项式的导函数', '/dataOJ/1.5.38计算多项式的导函数', '简单', '3000', '65536', '计算多项式的导函数是一件非常容易的任务。给定一个函数f(x)，我们用f\'(x)来表示其导函数。我们用x^n来表示x的n次幂。为了计算多项式的导函数，你必须知道三条规则：\n\n(1)、(C)\' = 0 如果C是常量\n\n(2)、(C*x^n)\' = C*n*x^(n-1) 如果n >= 1且C是常量\n\n(3)、(f1(x)+f2(2))\' = f1\'(x)+f2\'(x)\n\n容易证明，多项式的导函数也是多项式。\n\n现在，请你编写一个程序，给定一个不包含负系数且已合并好同幂次项的多项式f(x)，计算出它的导函数。\n\n', '输入有两行。\n第一行是一个整数n（0 <= n <= 100）表明多项式的最高次幂为n。\n第二行包含n+1个非负整数，Cn ，Cn-1 ，Cn-2 ，Cn-3 ，Cn-4 ，… ，C1，C0（0 <= Ci <= 1000）且Cn != 0。Ci是幂次为i的项的系数。\n', '在一行内输出f\'(x)的结果。\n（1） 如果g(x) = 0那么直接输出0\n（2） 如果g(x)形如Cm(x^m)+Cm-1(x^(m-1))+…+C0(Cm!=0)那么输出Cm…C0\n（3） 相邻整数之间有单个空格。\n', '3\n0\n10\n2\n3 2 1\n3\n10 0 1 2\n', '0\n6 2\n30 0 1\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('151', '与7无关的数', '/dataOJ/1.5.39与7无关的数', '简单', '3000', '65536', '一个正整数,如果它能被7整除,或者它的十进制表示法中某一位上的数字为7,则称其为与7相关的数.现求所有小于等于n(n < 100)的与7无关的正整数的平方和.\n\n', '输入为一行,正整数n(n < 100)\n', '输出一行，包含一个整数，即小于等于n的所有与7无关的正整数的平方和。\n', '21\n', '2336\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('152', '数1的个数', '/dataOJ/1.5.40数1的个数', '简单', '3000', '65536', '给定一个十进制正整数n，写下从1到n的所有整数，然后数一下其中出现的数字“1”的个数。\n\n例如当n=2时，写下1,2。这样只出现了1个“1”；当n=12时，写下1，2，3，4，5，6，7，8，9，10，11，12。这样出现了5个“1”。\n\n', '正整数n。1 <= n <= 10000。\n', '一个正整数，即“1”的个数。\n', '12\n', '5\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('153', '数字统计', '/dataOJ/1.5.41数字统计', '简单', '3000', '65536', '请统计某个给定范围[L, R]的所有整数中，数字2出现的次数。\n\n比如给定范围[2, 22]，数字2在数2中出现了1次，在数12中出现1次，在数20中出现1次，在数21中出现1次，在数22中出现2次，所以数字2在该范围内一共出现了6次。\n\n', '输入共 1 行，为两个正整数 L 和 R，之间用一个空格隔开。\n', '输出共 1 行，表示数字 2 出现的次数。\n', '样例 #1：\n2 22\n\n样例 #2：\n2 100\n', '样例 #1：\n6\n\n样例 #2：\n20\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('154', '画矩形', '/dataOJ/1.5.42画矩形', '简单', '3000', '65536', '根据参数，画出矩形。\n\n', '输入一行，包括四个参数：前两个参数为整数，依次代表矩形的高和宽（高不少于3行不多于10行，宽不少于5列不多于10列）；第三个参数是一个字符，表示用来画图的矩形符号；第四个参数为1或0，0代表空心，1代表实心。\n', '输出画出的图形。\n', '7 7 @ 0\n', '@@@@@@@\n@     @\n@     @\n@     @\n@     @\n@     @\n@@@@@@@\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('155', '第n小的质数', '/dataOJ/1.5.44第n小的质数', '简单', '3000', '65536', '输入一个正整数n，求第n小的质数。\n\n', '一个不超过10000的正整数n。\n', '第n小的质数。\n', '10\n', '29\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('156', '金币', '/dataOJ/1.5.45金币', '简单', '3000', '65536', '国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天）里，每天收到两枚金币；之后三天（第四、五、六天）里，每天收到三枚金币；之后四天（第七、八、九、十天）里，每天收到四枚金币……这种工资发放模式会一直这样延续下去：当连续N天每天收到N枚金币后，骑士会在之后的连续N+1天里，每天收到N+1枚金币（N为任意正整数）。\n\n你需要编写一个程序，确定从第一天开始的给定天数内，骑士一共获得了多少金币。\n\n', '一个整数（范围1到10000），表示天数。\n', '骑士获得的金币数。\n', '6\n', '14\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('157', '求整数的和与均值', '/dataOJ/1.5.4求整数的和与均值', '简单', '3000', '65536', '读入n（1 <= n <= 10000）个整数，求它们的和与均值。\n\n', '输入第一行是一个整数n，表示有n个整数。\n第2~n+1行每行包含1个整数。每个整数的绝对值均不超过10000。\n', '输出一行，先输出和，再输出平均值（保留到小数点后5位），两个数间用单个空格分隔。\n', '4\n344\n222\n343\n222\n', '1131 282.75000\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('158', '最高的分数', '/dataOJ/1.5.5最高的分数', '简单', '3000', '65536', '孙老师讲授的《计算概论》这门课期中考试刚刚结束，他想知道考试中取得的最高分数。因为人数比较多，他觉得这件事情交给计算机来做比较方便。你能帮孙老师解决这个问题吗？\n\n', '输入两行，第一行为整数n（1 <= n < 100），表示参加这次考试的人数.第二行是这n个学生的成绩，相邻两个数之间用单个空格隔开。所有成绩均为0到100之间的整数。\n', '输出一个整数，即最高的成绩。\n', '5\n85 78 90 99 60\n', '99\n', '无', '2023-12-03 23:52:50', '1');
INSERT INTO `oj_problem` VALUES ('159', '整数序列的元素最大跨度值', '/dataOJ/1.5.6整数序列的元素最大跨度值', '简单', '3000', '65536', '给定一个长度为n的非负整数序列，请计算序列的最大跨度值（最大跨度值 = 最大值减去最小值）。\n\n', '一共2行，第一行为序列的个数n（1 <= n <= 1000)，第二行为序列的n个不超过1000的非负整数，整数之间以一个空格分隔。\n', '输出一行，表示序列的最大跨度值。\n', '6\n3 0 8 7 5 9\n', '9\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('160', '奥运奖牌计数', '/dataOJ/1.5.7奥运奖牌计数', '简单', '3000', '65536', '2008年北京奥运会，A国的运动员参与了n天的决赛项目(1≤n≤17)。现在要统计一下A国所获得的金、银、铜牌数目及总奖牌数。\n\n', '输入n＋1行，第1行是A国参与决赛项目的天数n，其后n行，每一行是该国某一天获得的金、银、铜牌数目，以一个空格分开。\n', '输出1行，包括4个整数，为A国所获得的金、银、铜牌总数及总奖牌数，以一个空格分开。\n', '3\n1 0 3\n3 1 0\n0 3 0\n', '4 4 3 11\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('161', '多边形内角和', '/dataOJ/1.5.8多边形内角和', '简单', '3000', '65536', '在欧几里德几何中，n边形的内角和是(n-2)*180°。已知其中(n-1)个内角的度数，就能计算出剩下的一个未知内角的度数。请编写一个程序，来解决这个问题。\n\n', '第1行只有一个整数n(2第2行有(n-1)个正整数，是每个已知内角的度数。相邻两个整数之间用单个空格隔开。\n数据保证给定多边形合法。\n', '一个正整数，为未知内角的度数。\n', '3\n45 60\n\n', '75\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('162', '奇数求和', '/dataOJ/1.5.9奇数求和', '简单', '3000', '65536', '计算非负整数 m 到 n（包括m 和 n ）之间的所有奇数的和，其中，m 不大于 n，且n 不大于300。例如 m=3, n=12, 其和则为：3+5+7+9+11=35。\n\n', '两个数 m 和 n，两个数以一个空格分开，其中 0 <= m <= n <= 300 。\n', '输出一行，包含一个整数，表示m 到 n（包括m 和 n ）之间的所有奇数的和\n', '7 15\n', '55\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('163', '大整数加法', '/dataOJ/1.6.10大整数加法', '简单', '3000', '65536', '求两个不超过200位的非负整数的和。\n\n', '有两行，每行是一个不超过200位的非负整数，可能有多余的前导0。\n', '一行，即相加后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。\n', '22222222222222222222\n33333333333333333333\n', '55555555555555555555\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('164', '大整数减法', '/dataOJ/1.6.11大整数减法', '简单', '3000', '65536', '求两个大的正整数相减的差。\n\n', '共2行，第1行是被减数a，第2行是减数b(a > b)。每个大整数不超过200位，不会有多余的前导零。\n', '一行，即所求的差。\n', '9999999999999999999999999999999999999\n9999999999999\n', '9999999999999999999999990000000000000\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('165', '计算2的N次方', '/dataOJ/1.6.12计算2的N次方', '简单', '3000', '65536', '任意给定一个正整数N(N<=100)，计算2的n次方的值。\n', '输入一个正整数N。\n', '输出2的N次方的值。\n', '5\n', '32\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('166', '大整数的因子', '/dataOJ/1.6.13大整数的因子', '简单', '3000', '65536', '已知正整数k满足2<=k<=9，现给出长度最大为40位的十进制非负整数c，求所有能整除c的k。\n\n', '一个非负整数c，c的位数<=40。\n', '若存在满足 c%k == 0 的k，从小到大输出所有这样的k，相邻两个数之间用单个空格隔开；若没有这样的k，则输出\"none\"。\n', '30\n', '2 3 5 6 \n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('167', '求10000以内n的阶乘', '/dataOJ/1.6.14求10000以内n的阶乘', '简单', '3000', '65536', '求10000以内n的阶乘。\n\n', '只有一行输入，整数n（0<=n<=10000）。\n', '一行，即n!的值。\n', '100\n', '93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('168', '与指定数字相同的数的个数', '/dataOJ/1.6.1与指定数字相同的数的个数', '简单', '3000', '65536', '输出一个整数序列中与指定数字相同的数的个数。\n\n', '输入包含三行：\n第一行为N，表示整数序列的长度(N <= 100)；\n第二行为N个整数，整数之间以一个空格分开；\n第三行包含一个整数，为指定的整数m。\n', '输出为N个数中与m相同的数的个数。\n', '3\n2 3 2\n2\n', '2\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('169', '计算书费', '/dataOJ/1.6.3计算书费', '简单', '3000', '65536', '下面是一个图书的单价表：\n计算概论 28.9 元/本\n数据结构与算法 32.7 元/本\n数字逻辑 45.6元/本\nC++程序设计教程 78 元/本\n人工智能 35 元/本\n计算机体系结构 86.2 元/本\n编译原理 27.8元/本\n操作系统 43 元/本\n计算机网络 56 元/本\nJAVA程序设计 65 元/本\n给定每种图书购买的数量，编程计算应付的总费用。\n\n', '输入一行，包含10个整数(大于等于0，小于等于100)，分别表示购买的《计算概论》、《数据结构与算法》、《数字逻辑》、《C++程序设计教程》、《人工智能》、《计算机体系结构》、《编译原理》、《操作系统》、《计算机网络》、《JAVA程序设计》的数量（以本为单位）。每两个整数用一个空格分开。\n', '输出一行，包含一个浮点数f，表示应付的总费用。精确到小数点后一位。\n', '1 5 8 10 5 1 1 2 3 4\n', '2140.2\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('170', '数组逆序重放', '/dataOJ/1.6.4数组逆序重放', '简单', '3000', '65536', '将一个数组中的值按逆序重新存放。例如，原来的顺序为8,6,5,4,1。要求改为1,4,5,6,8。\n', '输入为两行：第一行数组中元素的个数n（1<n<100)，第二行是n个整数，每两个整数之间用空格分隔。\n', '输出为一行：输出逆序后数组的整数，每两个整数之间用空格分隔。\n', '5\n8 6 5 4 1\n', '1 4 5 6 8\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('171', '年龄与疾病', '/dataOJ/1.6.5年龄与疾病', '简单', '3000', '65536', '某医院想统计一下某项疾病的获得与否与年龄是否有关，需要对以前的诊断记录进行整理，按照0-18、19-35、36-60、61以上（含61）四个年龄段统计的患病人数占总患病人数的比例。\n\n', '共2行，第一行为过往病人的数目n（0 < n <= 100)，第二行为每个病人患病时的年龄。\n', '按照0-18、19-35、36-60、61以上（含61）四个年龄段输出该段患病人数占总患病人数的比例，以百分比的形式输出，精确到小数点后两位。每个年龄段占一行，共四行。\n', '10\n1 11 21 31 41 51 61 71 81 91\n', '20.00%\n20.00%\n20.00%\n40.00%\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('172', '有趣的跳跃', '/dataOJ/1.6.7有趣的跳跃', '简单', '3000', '65536', '一个长度为n（n>0）的序列中存在“有趣的跳跃”当前仅当相邻元素的差的绝对值经过排序后正好是从1到(n-1)。例如，1 4 2 3存在“有趣的跳跃”，因为差的绝对值分别为3,2,1。当然，任何只包含单个元素的序列一定存在“有趣的跳跃”。你需要写一个程序判定给定序列是否存在“有趣的跳跃”。\n\n', '一行，第一个数是n（0 < n < 3000），为序列长度，接下来有n个整数，依次为序列中各元素，各元素的绝对值均不超过1,000,000,000。\n', '一行，若该序列存在“有趣的跳跃”，输出\"Jolly\"，否则输出\"Not jolly\"。\n', '4 1 4 2 3\n', 'Jolly\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('173', '石头剪刀布', '/dataOJ/1.6.8石头剪刀布', '简单', '3000', '65536', '石头剪刀布是常见的猜拳游戏。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。\n\n一天，小A和小B正好在玩石头剪刀布。已知他们的出拳都是有周期性规律的，比如：“石头-布-石头-剪刀-石头-布-石头-剪刀……”，就是以“石头-布-石头-剪刀”为周期不断循环的。请问，小A和小B比了N轮之后，谁赢的轮数多？\n\n', '输入包含三行。\n第一行包含三个整数：N，NA，NB，分别表示比了N轮，小A出拳的周期长度，小B出拳的周期长度。0 < N,NA,NB < 100。\n第二行包含NA个整数，表示小A出拳的规律。\n第三行包含NB个整数，表示小B出拳的规律。\n其中，0表示“石头”，2表示“剪刀”，5表示“布”。相邻两个整数之间用单个空格隔开。\n', '输出一行，如果小A赢的轮数多，输出A；如果小B赢的轮数多，输出B；如果两人打平，输出draw。\n', '10 3 4\n0 2 5\n0 5 0 2\n', 'A\n', '对于测试数据，猜拳过程为：\nA：0 2 5 0 2 5 0 2 5 0\nB：0 5 0 2 0 5 0 2 0 5\nA赢了4轮，B赢了2轮，双方打平4轮，所以A赢的轮数多。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('174', '向量点积计算', '/dataOJ/1.6.9向量点积计算', '简单', '3000', '65536', '在线性代数、计算几何中，向量点积是一种十分重要的运算。\n\n给定两个n维向量a=(a1,a2,...,an)和b=(b1,b2,...,bn)，求点积a·b=a1b1+a2b2+...+anbn。\n\n', '第一行是一个整数n。1 <= n <= 1000。\n第二行包含n个整数a1,a2,...,an。\n第三行包含n个整数b1,b2,...,bn。\n相邻整数之间用单个空格隔开。每个整数的绝对值都不超过1000。\n', '一个整数，即两个向量的点积结果。\n', '3\n1 4 6\n2 1 5\n', '36\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('175', '简单密码', '/dataOJ/1.7.10简单密码', '简单', '3000', '65536', 'Julius Caesar曾经使用过一种很简单的密码。对于明文中的每个字符，将它用它字母表中后5位对应的字符来代替，这样就得到了密文。比如字符A用F来代替。如下是密文和明文中字符的对应关系。\n\n密文\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\n明文\nV W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\n你的任务是对给定的密文进行解密得到明文。\n\n你需要注意的是，密文中出现的字母都是大写字母。密文中也包括非字母的字符，对这些字符不用进行解码。\n\n', '一行，给出密文，密文不为空，而且其中的字符数不超过200。\n', '输出一行，即密文对应的明文。\n', 'NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\n', 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('176', '潜伏者', '/dataOJ/1.7.11潜伏者', '简单', '3000', '65536', 'R国和S国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。\n\n历经艰险后，潜伏于S国的R国间谍小C终于摸清了S国军用密码的编码规则：\n\n1、    S国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所的内容均由大写字母‘A’—‘Z’构成（无空格等其他字母）。\n\n2、    S国对于每个字母规定了对应的“密字”。加密的过程就是将原信息中的所有字母替换为其对应的“密字”。\n\n3、    每个字母只对应一个唯一的“密字”，不同的字母对应不同的“密字”。“密字”可以和原字母相同。\n\n例如，若规定‘A’的密字为‘A’，‘B’的密字为‘C’（其他字母及密字略），则原信息“ABA”被加密为“ACA”。\n\n现在，小C通过内线掌握了S国网络上发送的一条加密信息及其对应的原信息。小C希望能通过这条信息，破译S国的军用密码。小C的破译过程是这样的：扫描原信息，对于原信息中的字母x（代表任一大写字母），找到其在加密信息中的对应大写字母y，并认为在密码里y是x的密字。如此进行下去直到停止于如下的某个状态：\n\n1、    所有信息扫描完毕，‘A’—‘Z’所有26个字母在原信息中均出现过并获得了相应的“密字”。\n\n2、    所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。\n\n3、    扫描中发现掌握的信息里有明显的自相矛盾或错误（违反S过密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。\n\n在小C忙得头昏脑胀之际，R国司令部又发来电报，要求他翻译另外一条从S国刚刚截取到的加密信息。现在请你帮助小C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。\n\n', '共3行，每行为一个长度在1到100之间的字符串。\n第1行为小C掌握的一条加密信息。\n第2行为第1行的加密信息所对应的原信息。\n第3行为R国司令部要求小C翻译的加密信息。\n输入数据保证所有字符串仅由大写字母‘A’—‘Z’构成，且第1行长度与第2行相等。\n', '共1行。\n若破译密码停止时出现2，3两种情况，请你输出“Failed”（不含引号，注意首字母大写，其它小写）。\n否则请输出利用密码翻译电报中加密信息后得到的原信息。\n', '样例 #1：\nAA\nAB\nEOWIE\n\n样例 #2：\nQWERTYUIOPLKJHGFDSAZXCVBN\nABCDEFGHIJKLMNOPQRSTUVWXY\nDSLIEWO\n\n样例 #3：\nMSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO\n', '样例 #1：\nFailed\n\n样例#2：\nFailed\n\n样例#3：\nNOIP\n', '输入输出样例1说明：原信息中的字母‘A’和‘B’对应相同的密字，输出“Failed”。\n\n输入输出样例2说明：字母‘Z’在原信息中没有出现，输出“Failed”。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('177', '加密的病历单', '/dataOJ/1.7.12加密的病历单', '简单', '3000', '65536', '小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。\n在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。\n经过研究，小英发现了如下加密规律（括号中是一个“原文 -> 密文”的例子）\n1.  原文中所有的字符都在字母表中被循环左移了三个位置（dec  -> abz）\n2.  逆序存储（abcd -> dcba ）\n3.  大小写反转（abXY -> ABxy）\n\n', '一个加密的字符串。（长度小于50且只包含大小写字母）\n', '输出解密后的字符串。\n', 'GSOOWFASOq\n', 'Trvdizrrvj\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('178', '整理药名', '/dataOJ/1.7.15整理药名', '简单', '3000', '65536', '医生在书写药品名的时候经常不注意大小写，格式比较混乱。现要求你写一个程序将医生书写混乱的药品名整理成统一规范的格式，即药品名的第一个字符如果是字母要大写，其他字母小写。如将ASPIRIN、aspirin整理成Aspirin。\n\n', '第一行一个数字n，表示有n个药品名要整理，n不超过100。\n接下来n行，每行一个单词，长度不超过20，表示医生手书的药品名。药品名由非空字符组成。\n', 'n行，每行一个单词，对应输入的药品名的规范写法。\n', '4\nAspiRin\ncisapride\n2-PENICILLIN\nCefradine-6\n', 'Aspirin\nCisapride\n2-penicillin\nCefradine-6\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('179', '忽略大小写的字符串比较', '/dataOJ/1.7.16忽略大小写的字符串比较', '简单', '3000', '65536', '一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到\'\\0\'为止。如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准（注意：如果某个字符串遇到\'\\0\'而另一个字符串还未遇到\'\\0\'，则前者小于后者）。但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如\"Hello\"和\"hello\"在忽略字母大小写时是相等的。请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。\n\n', '输入为两行，每行一个字符串，共两个字符串。（每个字符串长度都小于80）\n', '如果第一个字符串比第二个字符串小，输出一个字符\"<\"；\n如果第一个字符串比第二个字符串大，输出一个字符\">\"；\n如果两个字符串相等，输出一个字符\"=\"。\n', 'Hello, how are you?\nhello, How are you?\n', '=\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('180', '字符串判等', '/dataOJ/1.7.17字符串判等', '简单', '3000', '65536', '判断两个由大小写字母和空格组成的字符串在忽略大小写，且忽略空格后是否相等。\n\n', '两行，每行包含一个字符串。\n', '若两个字符串相等，输出YES，否则输出NO。\n', 'a A bb BB ccc CCC\nAa BBbb CCCccc\n', 'YES\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('181', '验证子串', '/dataOJ/1.7.18验证子串', '简单', '3000', '65536', '输入两个字符串，验证其中一个串是否为另一个串的子串。\n\n', '输入两个字符串， 每个字符串占一行，长度不超过200且不含空格。\n', '若第一个串s1是第二个串s2的子串，则输出(s1) is substring of (s2)\n否则，若第二个串s2是第一个串s1的子串，输出(s2) is substring of (s1)\n否则，输出 No substring。\n', 'abc\ndddncabca\n', 'abc is substring of dddncabca\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('182', '字符串移位包含问题', '/dataOJ/1.7.19字符串移位包含问题', '简单', '3000', '65536', '对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。\n\n给定两个字符串s1和s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。例如CDAA是由AABCD两次移位后产生的新串BCDAA的子串，而ABCD与ACBD则不能通过多次移位来得到其中一个字符串是新串的子串。\n\n', '一行，包含两个字符串，中间由单个空格隔开。字符串只包含字母和数字，长度不超过30。\n', '如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出true，否则输出false。\n', 'AABCD CDAA\n', 'true\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('183', '统计数字字符个数', '/dataOJ/1.7.1统计数字字符个数', '简单', '3000', '65536', '输入一行字符，统计出其中数字字符的个数。\n\n', '一行字符串，总长度不超过255。\n', '输出为1行，输出字符串里面数字字符的个数。\n', 'Peking University is set up at 1898.\n', '4\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('184', '删除单词后缀', '/dataOJ/1.7.20删除单词后缀', '简单', '3000', '65536', '给定一个单词，如果该单词以er、ly或者ing后缀结尾， 则删除该后缀（题目保证删除后缀后的单词长度不为0）， 否则不进行任何操作。\n\n', '输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为32）。\n', '输出按照题目要求处理后的单词。\n', 'referer\n', 'refer\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('185', '单词替换', '/dataOJ/1.7.21单词替换', '简单', '3000', '65536', '输入一个字符串，以回车结束（字符串长度<=100）。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。\n', '输入包括3行，\n第1行是包含多个单词的字符串 s;\n第2行是待替换的单词a(长度 <= 100);\n第3行是a将被替换的单词b(长度 <= 100).\n\ns, a, b 最前面和最后面都没有空格.\n', '输出只有 1 行，将s中所有单词a替换成b之后的字符串。\n', 'You want someone to help you\nYou\nI\n', 'I want someone to help you\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('186', '紧急措施', '/dataOJ/1.7.22紧急措施', '简单', '3000', '65536', '近日，一些热门网站遭受黑客入侵，这些网站的账号、密码及email的数据惨遭泄露。你在这些网站上注册若干账号（使用的用户名不一定相同），但是注册时使用了相同的email。你此时拿到了那份泄露的数据，希望尽快将自己的密码更改。策略如下：根据email找到你的用户名和密码，然后更改密码。更改的规则为：小写和大写交换，非字母字符保持不变。\n\n', '第一行为你的email地址，长度不超过50个字符且只包含字母、数字和‘@’符号。\n第二行为账号数N，N(0 < N < 10000)。\n接下来N行，每行表示一个账号，格式为：\n用户名 密码 email\n它们之间用单个空格分开。用户名、密码、email均不含空格，且长度不超过50个字符。\n', '有若干行，每行为你的一个账号，包括：你的账号，修改后的密码（之间用单个空格分隔）。\n如果没有你的账号，则输出empty。\n', '样例输入1：\nabc@pku.edu.cn\n5\nhelloKitty iLoveCats abc@pku.edu.cn\n2012 maya2012 cplusplus@exam.com\nKittyCat 5iKitty abc@pku.edu.cn\nprogram password teacher@exam.com\nwhoAmi Feb.29$ abc@pku.edu.cn\n\n样例输入2：\nabc@pku.edu.cn\n1\n2012 maya2012 cplusplus@exam.com\n', '样例输出1：\nhelloKitty IlOVEcATS\nKittyCat 5IkITTY\nwhoAmi fEB.29$\n\n样例输出2：\nempty\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('187', '过滤多余的空格', '/dataOJ/1.7.23过滤多余的空格', '简单', '3000', '65536', '一个句子中也许有多个连续空格，过滤掉多余的空格，只留下一个空格。\n\n', '一行，一个字符串（长度不超过200），句子的头和尾都没有空格。\n', '过滤之后的句子。\n', 'Hello      world.This is    c language.\n', 'Hello world.This is c language.\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('188', '单词的长度', '/dataOJ/1.7.24单词的长度', '简单', '3000', '65536', '输入一行单词序列，相邻单词之间由1个或多个空格间隔，请对应地计算各个单词的长度。\n\n注意，如果有标点符号（如连字符，逗号），标点符号算作与之相连的词的一部分。没有被空格间开的符号串，都算作单词。\n\n', '一行单词序列，最少1个单词，最多300个单词，单词之间用至少1个空格间隔。单词序列总长度不超过1000。\n', '依次输出对应单词的长度，之间以逗号间隔。\n', 'She was born in 1990-01-02  and  from Beijing city.\n', '3,3,4,2,10,3,4,7,5\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('189', '最长最短单词', '/dataOJ/1.7.25最长最短单词', '简单', '3000', '65536', '输入1行句子（不多于200个单词，每个单词长度不超过100），只包含字母、空格和逗号。单词由至少一个连续的字母构成，空格和逗号都是单词间的间隔。\n\n试输出第1个最长的单词和第1个最短单词。\n\n', '一行句子。\n', '两行输出：\n第1行，第一个最长的单词。\n第2行，第一个最短的单词。\n', 'I am studying Programming language C in Peking University\n', 'Programming\nI\n', '如果所有单词长度相同，那么第一个单词既是最长单词也是最短单词。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('190', '字符串最大跨距', '/dataOJ/1.7.26字符串最大跨距', '简单', '3000', '65536', '有三个字符串S,S1,S2，其中，S长度不超过300，S1和S2的长度不超过10。想检测S1和S2是否同时在S中出现，且S1位于S2的左边，并在S中互不交叉（即，S1的右边界点在S2的左边界点的左侧）。计算满足上述条件的最大跨距（即，最大间隔距离：最右边的S2的起始点与最左边的S1的终止点之间的字符数目）。如果没有满足条件的S1，S2存在，则输出-1。\n\n例如，S = \"abcd123ab888efghij45ef67kl\", S1=\"ab\", S2=\"ef\"，其中，S1在S中出现了2次，S2也在S中出现了2次，最大跨距为：18。\n\n', '三个串：S, S1, S2，其间以逗号间隔（注意，S, S1, S2中均不含逗号和空格）；\n', 'S1和S2在S最大跨距；若在S中没有满足条件的S1和S2，则输出-1。\n', 'abcd123ab888efghij45ef67kl,ab,ef\n', '18\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('191', '单词翻转', '/dataOJ/1.7.27单词翻转', '简单', '3000', '65536', '输入一个句子（一行），将句子中的每一个单词翻转后输出。\n\n', '只有一行，为一个字符串，不超过500个字符。单词之间以空格隔开。\n', '翻转每一个单词后的字符串，单词之间的空格需与原文一致。\n', 'hello world\n', 'olleh dlrow\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('192', '单词倒排', '/dataOJ/1.7.28单词倒排', '简单', '3000', '65536', '编写程序，读入一行英文(只包含字母和空格，单词间以单个空格分隔)，将所有单词的顺序倒排并输出，依然以单个空格分隔。\n\n', '输入为一个字符串（字符串长度至多为100）。\n', '输出为按要求排序后的字符串。\n', 'I am a student\n', 'student a am I\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('193', '找第一个只出现一次的字符', '/dataOJ/1.7.2找第一个只出现一次的字符', '简单', '3000', '65536', '给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出no。\n\n', '一个字符串，长度小于100000。\n', '输出第一个仅出现一次的字符，若没有则输出no。\n', 'abcabd\n', 'c\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('194', '字符环', '/dataOJ/1.7.30字符环', '简单', '3000', '65536', '有两个由字符构成的环。请写一个程序，计算这两个字符环上最长连续公共字符串的长度。例如，字符串“ABCEFAGADEGKABUVKLM”的首尾连在一起，构成一个环；字符串“MADJKLUVKL”的首尾连在一起，构成一个另一个环；“UVKLMA”是这两个环的一个连续公共字符串。\n\n', '一行，包含两个字符串，分别对应一个字符环。这两个字符串之间用单个空格分开。字符串长度不超过255，且不包含空格等空白符。\n', '输出一个整数，表示这两个字符环上最长公共字符串的长度。\n', 'ABCEFAGADEGKABUVKLM MADJKLUVKL\n', '6\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('195', '字符串p型编码', '/dataOJ/1.7.31字符串p型编码', '简单', '3000', '65536', '给定一个完全由数字字符（\'0\',\'1\',\'2\',…,\'9\'）构成的字符串str，请写出str的p型编码串。例如：字符串122344111可被描述为\"1个1、2个2、1个3、2个4、3个1\"，因此我们说122344111的p型编码串为1122132431；类似的道理，编码串101可以用来描述1111111111；00000000000可描述为\"11个0\"，因此它的p型编码串即为110；100200300可描述为\"1个1、2个 0、1个2、2个0、1个3、2个0\"，因此它的p型编码串为112012201320。\n\n', '输入仅一行，包含字符串str。每一行字符串最多包含1000个数字字符。\n', '输出该字符串对应的p型编码串。\n', '122344111\n', '1122132431\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('196', '行程长度编码', '/dataOJ/1.7.32行程长度编码', '简单', '3000', '65536', '在数据压缩中，一个常用的途径是行程长度压缩。对于一个待压缩的字符串而言，我们可以依次记录每个字符及重复的次数。这种压缩，对于相邻数据重复较多的情况比较有效。 例如，如果待压缩串为\"AAABBBBCBB\"，则压缩的结果是(A,3)(B,4)(C,1)(B,2)。当然，如果相邻字符重复情况较少，则压缩效率就较低。\n\n现要求根据输入的字符串，得到大小写不敏感压缩后的结果（即所有小写字母均视为相应的大写字母）。\n\n', '一个字符串，长度大于0，且不超过1000，全部由大写或小写字母组成。\n', '输出为一行，表示压缩结果，形式为：\n(A,3)(B,4)(C,1)(B,2)\n即每对括号内部分别为字符（都为大写）及重复出现的次数，不含任何空格。\n', 'aAABBbBCCCaaaaa\n', '(A,3)(B,4)(C,3)(A,5)\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('197', '回文子串', '/dataOJ/1.7.34回文子串', '简单', '3000', '65536', '给定一个字符串，输出所有长度至少为2的回文子串。\n\n回文子串即从左往右输出和从右往左输出结果是一样的字符串，比如：abba，cccdeedccc都是回文字符串。\n\n', '一个字符串，由字母或数字组成。长度500以内。\n', '输出所有的回文子串，每个子串一行。\n子串长度小的优先输出，若长度相等，则出现位置靠左的优先输出。\n', '123321125775165561\n', '33\n11\n77\n55\n2332\n2112\n5775\n6556\n123321\n165561\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('198', '基因相关性', '/dataOJ/1.7.3基因相关性', '简单', '3000', '65536', '为了获知基因序列在功能和结构上的相似性，经常需要将几条不同序列的DNA进行比对，以判断该比对的DNA是否具有相关性。\n\n现比对两条长度相同的DNA序列。首先定义两条DNA序列相同位置的碱基为一个碱基对，如果一个碱基对中的两个碱基相同的话，则称为相同碱基对。接着计算相同碱基对占总碱基对数量的比例，如果该比例大于等于给定阈值时则判定该两条DNA序列是相关的，否则不相关。\n\n', '有三行，第一行是用来判定出两条DNA序列是否相关的阈值，随后2行是两条DNA序列（长度不大于500）。\n', '若两条DNA序列相关，则输出“yes”，否则输出“no”。\n', '', '', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('199', '石头剪子布', '/dataOJ/1.7.4石头剪子布', '简单', '3000', '65536', '石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。\n\n游戏规则：石头打剪刀，布包石头，剪刀剪布。\n\n现在，需要你写一个程序来判断石头剪子布游戏的结果。\n\n', '输入包括N+1行：\n第一行是一个整数N，表示一共进行了N次游戏。1 <= N <= 100。\n接下来N行的每一行包括两个字符串，表示游戏参与者Player1，Player2的选择（石头、剪子或者是布）：\nS1 S2\n字符串之间以空格隔开S1,S2只可能取值在{\"Rock\", \"Scissors\", \"Paper\"}（大小写敏感）中。\n', '输出包括N行，每一行对应一个胜利者（Player1或者Player2），或者游戏出现平局，则输出Tie。\n', '3\nRock Scissors\nPaper Paper\nRock Paper\n', 'Player1\nTie\nPlayer2\n', 'Rock是石头，Scissors是剪刀，Paper是布。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('200', '输出亲朋字符串', '/dataOJ/1.7.5输出亲朋字符串', '简单', '3000', '65536', '编写程序，求给定字符串s的亲朋字符串s1。\n\n亲朋字符串s1定义如下：给定字符串s的第一个字符的ASCII值加第二个字符的ASCII值，得到第一个亲朋字符； 给定字符串s的第二个字符的ASCII值加第三个字符的ASCII值，得到第二个亲朋字符；依此类推，直到给定字符串s的倒数第二个字符。亲朋字符串的最 后一个字符由给定字符串s的最后一个字符ASCII值加s的第一个字符的ASCII值。\n\n', '输入一行，一个长度大于等于2，小于等于100的字符串。字符串中每个字符的ASCII值不大于63。\n', '输出一行，为变换后的亲朋字符串。输入保证变换后的字符串只有一行。\n', '1234\n', 'cege\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('201', '合法 C 标识符', '/dataOJ/1.7.6合法 C 标识符', '简单', '3000', '65536', '给定一个不包含空白符的字符串，请判断是否是C语言合法的标识符号（注：题目保证这些字符串一定不是C语言的保留字）。\n\nC语言标识符要求：\n\n1. 非保留字；\n\n2. 只包含字母、数字及下划线（“_”）。\n\n3. 不以数字开头。\n\n', '一行，包含一个字符串，字符串中不包含任何空白字符，且长度不大于20。\n', '一行，如果它是C语言的合法标识符，则输出yes，否则输出no。\n', 'RKPEGX9R;TWyYcp\n', 'no\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('202', '配对碱基链', '/dataOJ/1.7.7配对碱基链', '简单', '3000', '65536', '脱氧核糖核酸（DNA）由两条互补的碱基链以双螺旋的方式结合而成。而构成DNA的碱基共有4种，分别为腺瞟呤（A）、鸟嘌呤（G）、胸腺嘧啶（T）和胞嘧啶（C）。我们知道，在两条互补碱基链的对应位置上，腺瞟呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。你的任务就是根据一条单链上的碱基序列，给出对应的互补链上的碱基序列。\n\n', '一个字符串，表示一条碱基链。这个字符串只含有大写字母A、T、G、C，分别表示腺瞟呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。字符串长度不超过255。\n', '一个只含有大写字母A、T、G、C的字符串，为与输入的碱基链互补的碱基链。\n', 'ATATGGATGGTGTTTGGCTCTG\n', 'TATACCTACCACAAACCGAGAC\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('203', '字符替换', '/dataOJ/1.7.8字符替换', '简单', '3000', '65536', '把一个字符串中特定的字符全部用给定的字符替换，得到一个新的字符串。\n\n', '只有一行，由一个字符串和两个字符组成，中间用单个空格隔开。字符串是待替换的字符串，字符串长度小于等于30个字符，且不含空格等空白符；\n接下来一个字符为需要被替换的特定字符；\n接下来一个字符为用于替换的给定字符。\n', '一行，即替换后的字符串。\n', 'hello-how-are-you o O\n', 'hellO-hOw-are-yOu\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('204', '密码翻译', '/dataOJ/1.7.9密码翻译', '简单', '3000', '65536', '在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y，A-Y的字母用其后继字母替代，把z和Z用a和A替代，其他非字母字符不变，则可得到一个简单的加密字符串。\n\n', '输入一行，包含一个字符串，长度小于80个字符。\n', '输出每行字符串的加密字符串。\n', 'Hello! How are you!\n', 'Ifmmp! Ipx bsf zpv!\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('205', '矩阵转置', '/dataOJ/1.8.10矩阵转置', '简单', '3000', '65536', '输入一个n行m列的矩阵A，输出它的转置AT。\n\n', '第一行包含两个整数n和m，表示矩阵A的行数和列数。1 <= n <= 100，1 <= m <= 100。\n接下来n行，每行m个整数，表示矩阵A的元素。相邻两个整数之间用单个空格隔开，每个元素均在1~1000之间。\n', 'm行，每行n个整数，为矩阵A的转置。相邻两个整数之间用单个空格隔开。\n', '3 3\n1 2 3\n4 5 6\n7 8 9\n', '1 4 7\n2 5 8\n3 6 9\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('206', '图像旋转', '/dataOJ/1.8.11图像旋转', '简单', '3000', '65536', '输入一个n行m列的黑白图像，将它顺时针旋转90度后输出。\n\n', '第一行包含两个整数n和m，表示图像包含像素点的行数和列数。1 <= n <= 100，1 <= m <= 100。\n接下来n行，每行m个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。\n', 'm行，每行n个整数，为顺时针旋转90度后的图像。相邻两个整数之间用单个空格隔开。\n', '3 3\n1 2 3\n4 5 6\n7 8 9\n', '7 4 1\n8 5 2\n9 6 3\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('207', '变幻的矩阵', '/dataOJ/1.8.12变幻的矩阵', '简单', '3000', '65536', '有一个N x N（N为奇数，且1 <= N <= 10）的矩阵，矩阵中的元素都是字符。这个矩阵可能会按照如下的几种变幻法则之一进行变幻（只会变幻一次）。\n\n现在给出一个原始的矩阵，和一个变幻后的矩阵，请编写一个程序，来判定原始矩阵是按照哪一种法则变幻为目标矩阵的。\n\n1. 按照顺时针方向旋转90度；\n如：\n\n1 2 3        7 4 1\n4 5 6 变幻为  8 5 2\n7 8 9        9 6 3\n\n2. 按照逆时针方向旋转90度；\n如：\n1 2 3        3 6 9\n4 5 6 变幻为  2 5 8\n7 8 9        1 4 7 \n\n3. 中央元素不变（如下例中的 5），其他元素（如下例中的3）与“以中央元素为中心的对应元素”（如下例中的7）互换；\n如：\n1 2 3       9 8 7\n4 5 6 变幻为 6 5 4\n7 8 9       3 2 1 \n\n4. 保持原始矩阵，不变幻；\n\n5. 如果 从原始矩阵 到 目标矩阵 的变幻，不符合任何上述变幻，请输出5\n', '第一行：矩阵每行/列元素的个数 N；\n第二行到第N+1行：原始矩阵，共N行，每行N个字符；\n第N+2行到第2*N+1行：目标矩阵，共N行，每行N个字符；\n', '只有一行，从原始矩阵 到 目标矩阵 的所采取的 变幻法则的编号。\n', '5\na b c d e\nf g h i j\nk l m n o\np q r s t\nu v w x y\ny x w v u\nt s r q p\no n m l k\nj i h g f\ne d c b a\n', '3\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('208', '图像模糊处理', '/dataOJ/1.8.13图像模糊处理', '简单', '3000', '65536', '给定n行m列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：\n\n1. 四周最外侧的像素点灰度值不变；\n\n2. 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。\n\n', '第一行包含两个整数n和m，表示图像包含像素点的行数和列数。1 <= n <= 100，1 <= m <= 100。\n接下来n行，每行m个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。\n', 'n行，每行m个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。\n', '4 5\n100 0 100 0 50\n50 100 200 0 0\n50 50 100 100 200\n100 100 50 50 100\n', '100 0 100 0 50\n50 80 100 60 0\n50 80 100 90 200\n100 100 50 50 100\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('209', '扫雷游戏地雷数计算', '/dataOJ/1.8.14扫雷游戏地雷数计算', '简单', '3000', '65536', '扫雷游戏是一款十分经典的单机小游戏。它的精髓在于，通过已翻开格子所提示的周围格地雷数，来判断未翻开格子里是否是地雷。\n\n现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格的周围格地雷数。\n\n注：每个格子周围格有八个：上、下、左、右、左上、右上、左下、右下。\n\n', '第一行包含两个整数n和m，分别表示雷区的行数和列数。1 <= n <= 100, 1 <= m <= 100。\n接下来n行，每行m个字符，‘*’表示相应格子中是地雷，‘？’表示相应格子中无地雷。字符之间无任何分隔符。\n', 'n行，每行m个字符，描述整个雷区。若相应格中是地雷，则用‘*’表示，否则用相应的周围格地雷数表示。字符之间无任何分隔符。\n', '3 3\n*??\n???\n?*?\n', '*10\n221\n1*1\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('210', '细菌的繁殖与扩散', '/dataOJ/1.8.15细菌的繁殖与扩散', '简单', '3000', '65536', '在边长为9的正方形培养皿中，正中心位置有m个细菌。假设细菌的寿命仅一天，但每天可繁殖10个后代，而且这10个后代，有两个分布在原来的单元格中，其余的均匀分布在其四周相邻的八个单元格中。求经过n(1≤n≤4)天后，细菌在培养皿中的分布情况。\n\n', '输入为两个整数，第一个整数m表示中心位置细菌的个数（2 ≤ m ≤ 30），第二个整数n表示经过的天数（1 ≤ n ≤ 4）。\n', '输出九行九列整数矩阵，每行的整数之间用空格分隔。整个矩阵代表n天后细菌在培养皿上的分布情况。\n', '2 1\n', '0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 0 0 0\n0 0 0 2 4 2 0 0 0\n0 0 0 2 2 2 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('211', '矩阵剪刀石头布', '/dataOJ/1.8.16矩阵剪刀石头布', '简单', '3000', '65536', 'Bart的妹妹Lisa在一个二维矩阵上创造了新的文明。矩阵上每个位置被三种生命形式之一占据：石头，剪刀，布。每天，上下左右相邻的不同生命形式将会发生战斗。在战斗中，石头永远胜剪刀，剪刀永远胜布，布永远胜石头。每一天结束之后，败者的领地将被胜者占领。\n\n你的工作是计算出n天之后矩阵的占据情况。\n\n', '第一行包含三个正整数r，c，n，分别表示矩阵的行数、列数以及天数。每个整数均不超过100。\n接下来r行，每行c个字符，描述矩阵初始时被占据的情况。每个位置上的字符只能是R，S，P三者之一，分别代表石头，剪刀，布。相邻字符之间无空格。\n', '输出n天之后的矩阵占据情况。每个位置上的字符只能是R，S，P三者之一，相邻字符之间无空格。\n', '3 3 1\nRRR\nRSR\nRRR\n', 'RRR\nRRR\nRRR\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('212', '最好的草', '/dataOJ/1.8.17最好的草', '简单', '3000', '65536', '奶牛Bessie计划好好享受柔软的春季新草。新草分布在R行C列的牧场里。它想计算一下牧场中的草丛数量。\n\n在牧场地图中，每个草丛要么是单个“#”，要么是有公共边的相邻两个“#”。给定牧场地图，计算有多少个草丛。\n\n例如，考虑如下5行6列的牧场地图\n\n.#....\n..#...\n..#..#\n...##.\n.#....\n这个牧场有5个草丛：一个在第一行，一个在第二列横跨了二、三行，一个在第三行，一个在第四行横跨了四、五列，最后一个在第五行。\n\n\n\n', '第一行包含两个整数R和C，中间用单个空格隔开。\n接下来R行，每行C个字符，描述牧场地图。字符只有“#”或“.”两种。(1 <= R, C <= 100 )\n', '输出一个整数，表示草丛数。\n', '5 6\n.#....\n..#...\n..#..#\n...##.\n.#....\n', '5\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('213', '肿瘤面积', '/dataOJ/1.8.18肿瘤面积', '简单', '3000', '65536', '在一个正方形的灰度图片上，肿瘤是一块矩形的区域，肿瘤的边缘所在的像素点在图片中用0表示。其它肿瘤内和肿瘤外的点都用255表示。现在要求你编写一个程序，计算肿瘤内部的像素点的个数（不包括肿瘤边缘上的点）。已知肿瘤的边缘平行于图像的边缘。\n\n', '只有一个测试样例。第一行有一个整数n，表示正方形图像的边长。其后n行每行有n个整数，取值为0或255。整数之间用一个空格隔开。已知n不大于1000。\n', '输出一行，该行包含一个整数，为要求的肿瘤内的像素点的个数。\n', '5\n255 255 255 255 255\n255 0 0 0 255\n255 0 255 0 255\n255 0 0 0 255\n255 255 255 255 255\n', '1\n', '如果使用静态数组来表示图片数据，需要将该数组定义成全局变量。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('214', '肿瘤检测', '/dataOJ/1.8.19肿瘤检测', '简单', '3000', '65536', '一张CT扫描的灰度图像可以用一个N*N（0 < N <= 100）的矩阵描述，矩阵上的每个点对应一个灰度值（整数），其取值范围是0-255。我们假设给定的图像中有且只有一个肿瘤。在图上监测肿瘤的方法如下：如果某个点对应的灰度值小于等于50，则这个点在肿瘤上，否则不在肿瘤上。我们把在肿瘤上的点的数目加起来，就得到了肿瘤在图上的面积。任何在肿瘤上的点，如果它是图像的边界或者它的上下左右四个相邻点中至少有一个是非肿瘤上的点，则该点称为肿瘤的边界点。肿瘤的边界点的个数称为肿瘤的周长。现在给定一个图像，要求计算其中的肿瘤的面积和周长。\n\n', '输入第一行包含一个正整数N（0 < N <= 100），表示图像的大小；接下来N行，每行包含图像的一行。图像的一行用N个整数表示（所有整数大于等于0，小于等于255），两个整数之间用一个空格隔开。\n', '输出只有一行，该行包含两个正整数，分别为给定图像中肿瘤的面积和周长，用一个空格分开。\n', '6\n99 99 99 99 99 99\n99 99 99 50 99 99\n99 99 49 49 50 51\n99 50 20 25 52 99\n40 50 99 99 99 99\n99 99 99 99 99 99\n', '9 8\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('215', '矩阵交换行', '/dataOJ/1.8.1矩阵交换行', '简单', '3000', '65536', '给定一个5*5的矩阵（数学上，一个r×c的矩阵是一个由r行c列元素排列成的矩形阵列），将第n行和第m行交换，输出交换后的结果。\n\n', '输入共6行，前5行为矩阵的每一行元素,元素与元素之间以一个空格分开。\n第6行包含两个整数m、n，以一个空格分开。（1 <= m,n <= 5）\n', '输出交换之后的矩阵，矩阵的每一行元素占一行，元素之间以一个空格分开。\n', '1 2 2 1 2\n5 6 7 8 3\n9 3 0 5 3\n7 2 1 4 6\n3 0 8 2 4\n1 5\n', '3 0 8 2 4\n5 6 7 8 3\n9 3 0 5 3\n7 2 1 4 6\n1 2 2 1 2\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('216', '反反复复', '/dataOJ/1.8.20反反复复', '简单', '3000', '65536', 'Mo和Larry发明了一种信息加密方法。他们首先决定好列数，然后将信息（只包含字母）从上往下依次填入各列，并在末尾补充一些随机字母使其成为一个完整的字母矩阵。例如，若信息是“There\'s no place like home on a snowy night”并且有5列，Mo会写成：\n\nt o i o y\nh p k n n\ne l e a i\nr a h s g\ne c o n h\ns e m o t\nn l e w x\n注意Mo只会填入字母，且全部是小写形式。在这个例子中，Mo用字母“x”填充了信息使之成为一个完整的矩阵，当然他使用任何字母都是可以的。\n\nMo根据这个矩阵重写信息：首先从左到右写下第一行，然后从右到左写下第二行，再从左到右写下第三行……以此左右交替地从上到下写下各行字母，形成新的字符串。这样，例子中的信息就被加密为：toioynnkpheleaigshareconhtomesnlewx。\n\n你的工作是帮助Larry从加密后的信息中还原出原始信息（包括填充的字母）。\n\n', '第一行包含一个整数（范围2到20），表示使用的列数。\n第二行是一个长度不超过200的字符串。\n', '一行，即原始信息。\n', '5\ntoioynnkpheleaigshareconhtomesnlewx\n', 'theresnoplacelikehomeonasnowynightx\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('217', '二维数组右上左下遍历', '/dataOJ/1.8.21二维数组右上左下遍历', '简单', '3000', '65536', '给定一个row行col列的整数数组array，要求从array[0][0]元素开始，按从左上到右下的对角线顺序遍历整个数组。\n \n', '输入的第一行上有两个整数，依次为row和col。\n余下有row行，每行包含col个整数，构成一个二维整数数组。\n（注：输入的row和col保证0 < row < 100, 0 < col < 100）\n', '按遍历顺序输出每个整数。每个整数占一行。\n', '3 4\n1 2 4 7\n3 5 8 10\n6 9 11 12\n', '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('218', '神奇的幻方', '/dataOJ/1.8.22神奇的幻方', '简单', '3000', '65536', '幻方是一个很神奇的N*N矩阵，它的每行、每列与对角线，加起来的数字和都是相同的。\n我们可以通过以下方法构建一个幻方。（阶数为奇数）\n1.第一个数字写在第一行的中间\n2.下一个数字，都写在上一个数字的右上方：\n    a.如果该数字在第一行，则下一个数字写在最后一行，列数为该数字的右一列\n    b.如果该数字在最后一列，则下一个数字写在第一列，行数为该数字的上一行\n    c.如果该数字在右上角，或者该数字的右上方已有数字，则下一个数字写在该数字的下方\n\n', '一个数字N（N<=20）\n', '按上方法构造的2N-1 * 2N-1的幻方\n', '3\n', '17 24 1 8 15\n23 5 7 14 16\n4 6 13 20 22\n10 12 19 21 3\n11 18 25 2 9\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('219', '二维数组回形遍历', '/dataOJ/1.8.23二维数组回形遍历', '简单', '3000', '65536', '给定一个row行col列的整数数组array，要求从array[0][0]元素开始，按回形从外向内顺时针顺序遍历整个数组。如图所示：\n\n\n\n', '输入的第一行上有两个整数，依次为row和col。\n余下有row行，每行包含col个整数，构成一个二维整数数组。\n（注：输入的row和col保证0 < row < 100, 0 < col < 100）\n', '按遍历顺序输出每个整数。每个整数占一行。\n', '4 4\n1 2 3 4\n12 13 14 5\n11 16 15 6\n10 9 8 7\n', '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('220', '蛇形填充数组', '/dataOJ/1.8.24蛇形填充数组', '简单', '3000', '65536', '用数字1,2,3,4,...,n*n这n2个数蛇形填充规模为n*n的方阵。\n\n蛇形填充方法为：\n\n对于每一条左下-右上的斜线，从左上到右下依次编号1,2,...,2n-1；按编号从小到大的顺序，将数字从小到大填入各条斜线，其中编号为奇数的从左下向右上填写，编号为偶数的从右上到左下填写。\n\n比如n=4时，方阵填充为如下形式：\n\n1  2  6  7\n3  5  8  13\n4  9  12 14\n10 11 15 16\n', '输入一个不大于10的正整数n，表示方阵的行数。\n', '输出该方阵，相邻两个元素之间用单个空格间隔。\n', '4\n', '1 2 6 7\n3 5 8 13\n4 9 12 14\n10 11 15 16\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('221', '螺旋加密', '/dataOJ/1.8.25螺旋加密', '简单', '3000', '65536', 'Chip和Dale发明了一种文本信息加密技术。他们事先秘密约定好矩阵的行数和列数。接着，将字符按如下方式编码：\n1. 所有文本只包含大写字母和空格。\n2. 每个字符均赋予一个数值：空格=0，A=1，B=2，……，Y=25，Z=26。\n按照下图所示的方式，将每个字符对应数值的5位二进制数依次填入矩阵。最后用0将矩阵补充完整。例如，对于信息“ACM”，行列数均为4时，矩阵将被填充为：\n \n将矩阵中的数字按行连起来形成数字串，完成加密。例子中的信息最终会被加密为：0000110100101100。\n', '一行。首先是两个整数R(1≤R≤20)和C(1≤C≤20)，表示行数和列数。之后是一个只包含大写字母和空格的字符串。字符串的长度≤(R*C)/5。R和C之间以及C和字符串之间均用单个空格隔开。\n', '一行，为加密后的二进制串。注意你可能需要用0将矩阵补充完整。\n', '4 4 ACM\n', '0000110100101100\n\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('222', '同行列对角线的格子', '/dataOJ/1.8.2同行列对角线的格子', '简单', '3000', '65536', '无', '输入描述', '输出描述', '', '', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('223', '错误探测', '/dataOJ/1.8.4错误探测', '简单', '3000', '65536', '给定n*n由0和1组成的矩阵，如果矩阵的每一行和每一列的1的数量都是偶数，则认为符合条件。\n你的任务就是检测矩阵是否符合条件，或者在仅改变一个矩阵元素的情况下能否符合条件。\n\"改变矩阵元素\"的操作定义为0变成1或者1变成0。\n\n', '输入n + 1行，第1行为矩阵的大小n(0 < n < 100)，以下n行为矩阵的每一行的元素，元素之间以一个空格分开。\n', '如果矩阵符合条件，则输出OK；\n如果矩阵仅改变一个矩阵元素就能符合条件，则输出需要改变的元素所在的行号和列号，以一个空格分开。\n如果不符合以上两条，输出Corrupt。\n', '样例输入1\n4\n1 0 1 0\n0 0 0 0\n1 1 1 1\n0 1 0 1\n\n样例输入2\n4\n1 0 1 0\n0 0 1 0\n1 1 1 1\n0 1 0 1\n\n样例输入3\n4\n1 0 1 0\n0 1 1 0\n1 1 1 1\n0 1 0 1\n', '样例输出1\nOK\n\n样例输出2\n2 3\n\n样例输出3\nCorrupt\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('224', '计算鞍点', '/dataOJ/1.8.5计算鞍点', '简单', '3000', '65536', '给定一个5*5的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。\n鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。\n例如：在下面的例子中（第4行第1列的元素就是鞍点，值为8 ）。\n11 3 5 6 9\n12 4 7 8 10\n10 5 6 9 11\n8 6 4 7 2\n15 10 11 20 25\n\n', '输入包含一个5行5列的矩阵\n', '如果存在鞍点，输出鞍点所在的行、列及其值，如果不存在，输出\"not found\"\n', '11 3 5 6 9\n12 4 7 8 10\n10 5 6 9 11\n8  6 4 7 2\n15 10 11 20 25\n', '4 1 8\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('225', '图像相似度', '/dataOJ/1.8.6图像相似度', '简单', '3000', '65536', '给出两幅相同大小的黑白图像（用0-1矩阵）表示，求它们的相似度。\n\n说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。\n\n', '第一行包含两个整数m和n，表示图像的行数和列数，中间用单个空格隔开。1 <= m <= 100, 1 <= n <= 100。\n之后m行，每行n个整数0或1，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。\n之后m行，每行n个整数0或1，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。\n', '一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位。\n', '3 3\n1 0 1\n0 0 1\n1 1 0\n1 1 0\n0 0 1\n0 0 1\n', '44.44\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('226', '矩阵归零消减序列和', '/dataOJ/1.8.7矩阵归零消减序列和', '简单', '3000', '65536', '给定一个n*n的矩阵（3 <= n <= 100，元素的值都是非负整数）。通过(n-1)次实施下述过程，可把这个矩阵转换成一个1*1的矩阵。每次的过程如下：\n\n首先对矩阵进行行归零：即对每一行上的所有元素，都在其原来值的基础上减去该行上的最小值，保证相减后的值仍然是非负整数，且这一行上至少有一个元素的值为0。\n\n接着对矩阵进行列归零：即对每一列上的所有元素，都在其原来值的基础上减去该列上的最小值，保证相减后的值仍然是非负整数，且这一列上至少有一个元素的值为0。\n\n然后对矩阵进行消减：即把n*n矩阵的第二行和第二列删除，使之转换为一个(n-1)*(n-1)的矩阵。\n\n下一次过程，对生成的(n-1)*(n-1)矩阵实施上述过程。显然，经过(n-1)次上述过程， n*n的矩阵会被转换为一个1*1的矩阵。\n\n请求出每次消减前位于第二行第二列的元素的值。\n\n\n\n\n', '第一行是一个整数n。\n接下来n行，每行有n个正整数，描述了整个矩阵。相邻两个整数间用单个空格分隔。\n', '输出为n行，每行上的整数为对应矩阵归零消减过程中，每次消减前位于第二行第二列的元素的值。\n', '3\n1 2 3\n2 3 4\n3 4 5\n', '3\n0\n0\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('227', '矩阵加法', '/dataOJ/1.8.8矩阵加法', '简单', '3000', '65536', '输入两个n行m列的矩阵A和B，输出它们的和A+B。\n\n', '第一行包含两个整数n和m，表示矩阵的行数和列数。1 <= n <= 100，1 <= m <= 100。\n接下来n行，每行m个整数，表示矩阵A的元素。\n接下来n行，每行m个整数，表示矩阵B的元素。\n相邻两个整数之间用单个空格隔开，每个元素均在1~1000之间。\n', 'n行，每行m个整数，表示矩阵加法的结果。相邻两个整数之间用单个空格隔开。\n', '3 3\n1 2 3\n1 2 3\n1 2 3\n1 2 3\n4 5 6\n7 8 9\n', '2 4 6\n5 7 9\n8 10 12\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('228', '矩阵乘法', '/dataOJ/1.8.9矩阵乘法', '简单', '3000', '65536', '计算两个矩阵的乘法。n*m阶的矩阵A乘以m*k阶的矩阵B得到的矩阵C 是n*k阶的，且C[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + …… +A[i][m-1]*B[m-1][j](C[i][j]表示C矩阵中第i行第j列元素)。\n\n', '第一行为n, m, k，表示A矩阵是n行m列，B矩阵是m行k列，n, m, k均小于100\n然后先后输入A和B两个矩阵，A矩阵n行m列，B矩阵m行k列，矩阵中每个元素的绝对值不会大于1000。\n', '输出矩阵C，一共n行，每行k个整数，整数之间以一个空格分开。\n', '3 2 3\n1 1\n1 1\n1 1\n1 1 1\n1 1 1\n', '2 2 2\n2 2 2\n2 2 2\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('229', '找最大数序列', '/dataOJ/1.9.10找最大数序列', '简单', '3000', '65536', '输入n行，每行不超过100个无符号整数，无符号数不超过4位。请输出最大整数以及最大整数所在的行号（行号从1开始）。如果该数据在多个行中出现，则按从小到大输出相应行号，行号之间以一个逗号分开。\n\n', '一行输入一个正整数n（n <= 30）。\n之后的n行，每行包含不超过100个无符号整数，整数之间以一个逗号分开。\n', '第一行：最大整数；\n第二行：最大整数所在的行编号，逗号间隔。\n', '6\n1,3,5,23,6,8,14\n20,22,13,4,16\n23,12,17,22\n2,6,10,9,3,6\n22,21,20,8,10\n22,1,23,6,8,19,23\n', '23\n1,3,6\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('230', '连续出现的字符', '/dataOJ/1.9.11连续出现的字符', '简单', '3000', '65536', '给定一个字符串，在字符串中找到第一个连续出现至少k次的字符。\n\n', '第一行包含一个正整数k，表示至少需要连续出现的次数。1 <= k <= 1000。\n第二行包含需要查找的字符串。字符串长度在1到1000之间，且不包含任何空白符。\n', '若存在连续出现至少k次的字符，输出该字符；否则输出No。\n', '3\nabcccaaab\n', 'c\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('231', '最长平台', '/dataOJ/1.9.12最长平台', '简单', '3000', '65536', '已知一个已经从小到大排序的数组，这个数组的一个平台（Plateau）就是连续的一串值相同的元素，并且这一串元素不能再延伸。例如，在 1，2，2，3，3，3，4，5，5，6中1，2-2，3-3-3，4，5-5，6都是平台。试编写一个程序，接收一个数组，把这个数组最长的平台找出 来。在上面的例子中3-3-3就是最长的平台。\n\n', '第一行有一个整数n(n <= 1000)，为数组元素的个数。第二行有n个整数，整数之间以一个空格分开。\n', '输出最长平台的长度。\n', '10\n1 2 2 3 3 3 4 5 5 6\n', '3\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('232', '整数去重', '/dataOJ/1.9.13整数去重', '简单', '3000', '65536', '给定含有n个整数的序列，要求对这个序列进行去重操作。所谓去重，是指对这个序列中每个重复出现的数，只保留该数第一次出现的位置，删除其余位置。\n\n', '输入包含两行：\n第一行包含一个正整数n（1 <= n <= 20000），表示第二行序列中数字的个数；\n第二行包含n个整数，整数之间以一个空格分开。每个整数大于等于10、小于等于100。\n', '输出只有一行，按照输入的顺序输出其中不重复的数字，整数之间用一个空格分开。\n', '5\n10 12 93 12 75\n', '10 12 93 75\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('233', '铺地毯', '/dataOJ/1.9.14铺地毯', '简单', '3000', '65536', '为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。\n输入输出样例1说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。\n输入输出样例2说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（4，5）的最上面一张地毯是3号地毯。\n \n\n', '输入共n+2行。\n第一行，一个整数n，表示总共有n张地毯。\n接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。\n第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。\n\n对于100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。\n', '输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。\n', '样例 #1：\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n2 2\n\n样例 #2：\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n4 5\n', '样例 #1：\n3\n\n样例 #2：\n-1\n\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('234', '接水问题', '/dataOJ/1.9.15接水问题', '简单', '3000', '65536', '学校里有一个水房，水房里一共装有 m 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 1。\n\n现在有 n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 1 到 n 编号，i号同学的接水量为 wi。接水开始时，1 到 m 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 j 完成其接水量要求 wj后，下一名排队等候接水的同学 k 马上接替 j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 j 同学第 x 秒结束时完成接水，则 k 同学第 x+1 秒立刻开始接水。 若当前接水人数 n’不足 m，则只有 n’个龙头供水，其它 m-n’个龙头关闭。\n\n现在给出 n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n\n', '第 1 行2 个整数 n 和 m，用一个空格隔开，分别表示接水人数和龙头个数。\n第 2 行 n 个整数 w1、w2、……、wn，每两个整数之间用一个空格隔开，wi表示 i 号同学的接水量。\n\n1 ≤ n ≤ 10000，1 ≤ m ≤ 100 且 m ≤ n；\n1 ≤ wi ≤ 100。\n', '输出只有一行，1 个整数，表示接水所需的总时间。\n', '样例 #1：\n5 3\n4 4 1 2 1\n\n样例 #2：\n8 4\n23 71 87 32 70 93 80 76\n', '样例 #1：\n4\n\n样例 #2：\n163\n', '输入输出样例1解释：\n第 1 秒，3 人接水。第 1秒结束时，1、2、3 号同学每人的已接水量为 1，3 号同学接完水，4 号同学接替 3 号同学开始接水。\n第 2 秒，3 人接水。第 2 秒结束时，1、2 号同学每人的已接水量为 2，4 号同学的已接水量为 1。\n第 3 秒，3 人接水。第 3 秒结束时，1、2 号同学每人的已接水量为 3，4 号同学的已接水量为 2。4号同学接完水，5 号同学接替 4 号同学开始接水。\n第 4 秒，3 人接水。第 4 秒结束时，1、2 号同学每人的已接水量为 4，5 号同学的已接水量为 1。1、2、5 号同学接完水，即所有人完成接水。\n总接水时间为 4 秒。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('235', '查找特定的值', '/dataOJ/1.9.1查找特定的值', '简单', '3000', '65536', '在一个序列（下标从1开始）中查找一个给定的值，输出第一次出现的位置。\n\n', '第一行包含一个正整数n，表示序列中元素个数。1 <= n <= 10000。\n第二行包含n个整数，依次给出序列的每个元素，相邻两个整数之间用单个空格隔开。元素的绝对值不超过10000。\n第三行包含一个整数x，为需要查找的特定值。x的绝对值不超过10000。\n', '若序列中存在x，输出x第一次出现的下标；否则输出-1。\n', '5\n2 3 6 7 3\n3\n', '2\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('236', '输出最高分数的学生姓名', '/dataOJ/1.9.2输出最高分数的学生姓名', '简单', '3000', '65536', '输入学生的人数，然后再输入每位学生的分数和姓名，求获得最高分数的学生的姓名。\n\n', '第一行输入一个正整数N（N <= 100），表示学生人数。接着输入N行，每行格式如下：\n分数 姓名\n分数是一个非负整数，且小于等于100；\n姓名为一个连续的字符串，中间没有空格，长度不超过20。\n数据保证最高分只有一位同学。\n', '获得最高分数同学的姓名。\n', '5\n87 lilei\n99 hanmeimei\n97 lily\n96 lucy\n77 jim\n', 'hanmeimei\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('237', '不高兴的津津', '/dataOJ/1.9.3不高兴的津津', '简单', '3000', '65536', '津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。\n\n', '包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。\n', '包括一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。\n', '5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n', '3\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('238', '谁拿了最多奖学金', '/dataOJ/1.9.4谁拿了最多奖学金', '简单', '3000', '65536', '某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：\n\n1)     院士奖学金，每人8000元，期末平均成绩高于80分（>80），并且在本学期内发表1篇或1篇以上论文的学生均可获得；\n\n2)     五四奖学金，每人4000元，期末平均成绩高于85分（>85），并且班级评议成绩高于80分（>80）的学生均可获得；\n\n3)     成绩优秀奖，每人2000元，期末平均成绩高于90分（>90）的学生均可获得；\n\n4)     西部奖学金，每人1000元，期末平均成绩高于85分（>85）的西部省份学生均可获得；\n\n5)     班级贡献奖，每人850元，班级评议成绩高于80分（>80）的学生干部均可获得；\n\n只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。\n\n\n\n现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。\n\n', '第一行是一个整数N（1 <= N <= 100），表示学生的总数。接下来的N行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。\n', '包括三行，第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。\n', '4\nYaoLin 87 82 Y N 0\nChenRuiyi 88 78 N Y 1\nLiXin 92 88 N N 0\nZhangQin 83 87 Y N 1\n', 'ChenRuiyi\n9000\n28700\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('239', '最大值和最小值的差', '/dataOJ/1.9.5最大值和最小值的差', '简单', '3000', '65536', '输出一个整数序列中最大的数和最小的数的差。\n\n', '第一行为M，表示整数个数，整数个数不会大于10000；\n第二行为M个整数，以空格隔开，每个整数的绝对值不会大于10000。\n', '输出M个数中最大值和最小值的差。\n', '5\n2 5 7 4 2\n', '5\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('240', '笨小猴', '/dataOJ/1.9.6笨小猴', '简单', '3000', '65536', '笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n\n这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。\n\n', '只有一行，是一个单词，其中只可能出现小写字母，并且长度小于100。\n', '共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；\n第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。\n', '样例 #1：\nerror\n\n样例 #2：\nolympic\n', '样例 #1：\nLucky Word\n2\n\n样例 #2：\nNo Answer\n0\n', '单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。\n单词olympic中出现最多的字母i出现了2次，出现次数最少的字母出现了1次，2-1=1，1不是质数。\n', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('241', '不与最大数相同的数字之和', '/dataOJ/1.9.7不与最大数相同的数字之和', '简单', '3000', '65536', '输出一个整数数列中不与最大数相同的数字之和。\n\n', '输入分为两行：\n第一行为N(N为接下来数的个数，N <= 100)；\n第二行为N个整数，数与数之间以一个空格分开，每个整数的范围是-1000,000到1000,000。\n', '输出为N个数中除去最大数其余数字之和。\n', '3\n1 2 3 \n', '3\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('242', '白细胞计数', '/dataOJ/1.9.8白细胞计数', '简单', '3000', '65536', '医院采样了某临床病例治疗期间的白细胞数量样本n份，用于分析某种新抗生素对该病例的治疗效果。为了降低分析误差，要先从这n份样本中去除一个数值最大的 样本和一个数值最小的样本，然后将剩余n-2个有效样本的平均值作为分析指标。同时，为了观察该抗生素的疗效是否稳定，还要给出该平均值的误差，即所有有 效样本（即不包括已扣除的两个样本）与该平均值之差的绝对值的最大值。\n\n现在请你编写程序，根据提供的n个样本值，计算出该病例的平均白细胞数量和对应的误差。\n\n', '输入的第一行是一个正整数n（2 < n <= 300），表明共有n个样本。\n以下共有n行，每行为一个浮点数，为对应的白细胞数量，其单位为10^9/L。数与数之间以一个空格分开。\n', '输出为两个浮点数，中间以一个空格分开。分别为平均白细胞数量和对应的误差，单位也是10^9/L。计算结果需保留到小数点后2位。\n', '5\n12.0\n13.0\n11.0\n9.0\n10.0\n', '11.00 1.00\n', '无', '2023-12-03 23:52:51', '1');
INSERT INTO `oj_problem` VALUES ('243', '直方图', '/dataOJ/1.9.9直方图', '简单', '3000', '65536', '给定一个非负整数数组，统计里面每一个数的出现次数。我们只统计到数组里最大的数。\n\n假设 Fmax （Fmax < 10000）是数组里最大的数，那么我们只统计 {0,1,2.....Fmax} 里每个数出现的次数。\n\n', '第一行n是数组的大小。1 <= n <= 10000。\n紧接着一行是数组的n个元素。\n', '按顺序输出每个数的出现次数，一行一个数。如果没有出现过，则输出0。\n对于例子中的数组，最大的数是3，因此我们只统计{0,1,2,3}的出现频数。\n', '5\n1 1 2 3 1\n', '0\n3\n1 \n1\n', '无', '2023-12-03 23:52:51', '1');

-- ----------------------------
-- Table structure for oj_problem_submit
-- ----------------------------
DROP TABLE IF EXISTS `oj_problem_submit`;
CREATE TABLE `oj_problem_submit` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `problem_id` int(11) DEFAULT NULL,
  `code` varchar(4096) CHARACTER SET utf8 DEFAULT NULL,
  `language` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `result` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `score` double(8,0) DEFAULT NULL,
  `run_ram` int(11) DEFAULT NULL,
  `run_time` int(11) DEFAULT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=114 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
-- Records of oj_problem_submit
-- ----------------------------
INSERT INTO `oj_problem_submit` VALUES ('1', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 11:17:35');
INSERT INTO `oj_problem_submit` VALUES ('2', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 17:22:50');
INSERT INTO `oj_problem_submit` VALUES ('3', '1', '1', '#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n\r\n{\r\n\r\n    cout<<\"                ********\"<<endl;\r\n\r\n    cout<<\"               ************\"<<endl;\r\n\r\n    cout<<\"               ####....#.\"<<endl;\r\n\r\n    cout<<\"             #..###.....##....\"<<endl;\r\n\r\n    cout<<\"             ###.......######              ###                 ###           ###           ###\"<<endl;\r\n\r\n    cout<<\"                ...........               #...#               #...#         #...#         #...#\"<<endl;\r\n\r\n    cout<<\"               ##*#######                 #.#.#               #.#.#         #.#.#         #.#.#\"<<endl;\r\n\r\n    cout<<\"            ####*******######             #.#.#               #.#.#         #.#.#         #.#.#\"<<endl;\r\n\r\n    cout<<\"           ...#***.****.*###....          #...#               #...#         #...#         #...#\"<<endl;\r\n\r\n    cout<<\"           ....**********##.....           ###                 ###           ###           ###\"<<endl;\r\n\r\n    cout<<\"           ....****    *****....\"<<endl;\r\n\r\n    cout<<\"             ####        ####\"<<endl;\r\n\r\n    cout<<\"           ######        ######\"<<endl;\r\n\r\n    cout<<\"##############################################################              ##################################\"<<endl;\r\n\r\n    cout<<\"#...#......#.##...#......#.##...#......#.##------------------#              #...#......#.##------------------#\"<<endl;\r\n\r\n    cout<<\"###########################################------------------#              ###############------------------#\"<<endl;\r\n\r\n    cout<<\"#..#....#....##..#....#....##..#....#....#####################              #..#....#....#####################\"<<endl;\r\n\r\n    cout<<\"##########################################    #----------#                  ##############    #----------#\"<<endl;\r\n\r\n    cout<<\"#.....#......##.....#......##.....#......#    #----------#                  #.....#......#    #----------#\"<<endl;\r\n\r\n    cout<<\"##########################################    #----------#                  ##############    #----------#\"<<endl;\r\n\r\n    cout<<\"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#                  #.#..#....#..#    #----------#\"<<endl;\r\n\r\n    cout<<\"##########################################    ############                  ##############    ############\"<<endl;\r\n\r\n    return 0;\r\n\r\n}', '1', 'WE', '0', null, null, '2023-12-11 17:57:35');
INSERT INTO `oj_problem_submit` VALUES ('4', '1', '1', 'import java.util.Scanner;\r\n\r\n\r\n\r\npublic class Main {\r\n\r\npublic static void main(String[] args) {\r\n\r\nScanner scanner = new Scanner(System.in);\r\n\r\nSystem.out. printf( \"                ********\\n\"+\r\n\r\n\r\n\r\n            \"               ************\\n\"+\r\n\r\n\r\n\r\n            \"               ####....#.\\n\"+\r\n\r\n\r\n\r\n            \"             #..###.....##....\\n\"+\r\n\r\n\r\n\r\n            \"             ###.......######              ###                 ###           ###           ###\\n\"+\r\n\r\n\r\n\r\n            \"                ...........               #...#               #...#         #...#         #...#\\n\"+\r\n\r\n\r\n\r\n            \"               ##*#######                 #.#.#               #.#.#         #.#.#         #.#.#\\n\"+\r\n\r\n\r\n\r\n            \"            ####*******######             #.#.#               #.#.#         #.#.#         #.#.#\\n\"+\r\n\r\n\r\n\r\n            \"           ...#***.****.*###....          #...#               #...#         #...#         #...#\\n\"+\r\n\r\n\r\n\r\n            \"           ....**********##.....           ###                 ###           ###           ###\\n\"+\r\n\r\n\r\n\r\n            \"           ....****    *****....\\n\"+\r\n\r\n\r\n\r\n            \"             ####        ####\\n\"+\r\n\r\n\r\n\r\n            \"           ######        ######\\n\"+\r\n\r\n\r\n\r\n            \"##############################################################              ##################################\\n\"+\r\n\r\n\r\n\r\n            \"#...#......#.##...#......#.##...#......#.##------------------#              #...#......#.##------------------#\\n\"+\r\n\r\n\r\n\r\n            \"###########################################------------------#              ###############------------------#\\n\"+\r\n\r\n\r\n\r\n            \"#..#....#....##..#....#....##..#....#....#####################              #..#....#....#####################\\n\"+\r\n\r\n\r\n\r\n            \"##########################################    #----------#                  ##############    #----------#\\n\"+\r\n\r\n\r\n\r\n            \"#.....#......##.....#......##.....#......#    #----------#                  #.....#......#    #----------#\\n\"+\r\n\r\n\r\n\r\n            \"##########################################    #----------#                  ##############    #----------#\\n\"+\r\n\r\n\r\n\r\n            \"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#                  #.#..#....#..#    #----------#\\n\"+\r\n\r\n\r\n\r\n            \"##########################################    ############                  ##############    ############\\n\");\r\n\r\n}\r\n\r\n}', '3', 'WE', '0', null, null, '2023-12-11 17:58:28');
INSERT INTO `oj_problem_submit` VALUES ('5', '1', '1', 'echo \"                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\";', '7', 'PE', '0', null, null, '2023-12-11 17:59:26');
INSERT INTO `oj_problem_submit` VALUES ('6', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 18:23:23');
INSERT INTO `oj_problem_submit` VALUES ('7', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 18:32:54');
INSERT INTO `oj_problem_submit` VALUES ('8', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 18:34:45');
INSERT INTO `oj_problem_submit` VALUES ('9', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 18:39:16');
INSERT INTO `oj_problem_submit` VALUES ('10', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 18:40:51');
INSERT INTO `oj_problem_submit` VALUES ('11', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 18:41:43');
INSERT INTO `oj_problem_submit` VALUES ('12', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 18:42:47');
INSERT INTO `oj_problem_submit` VALUES ('13', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:00:44');
INSERT INTO `oj_problem_submit` VALUES ('14', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:00:47');
INSERT INTO `oj_problem_submit` VALUES ('15', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:00:50');
INSERT INTO `oj_problem_submit` VALUES ('16', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:01:00');
INSERT INTO `oj_problem_submit` VALUES ('17', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:01:59');
INSERT INTO `oj_problem_submit` VALUES ('18', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:02:39');
INSERT INTO `oj_problem_submit` VALUES ('19', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 19:04:07');
INSERT INTO `oj_problem_submit` VALUES ('20', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 19:06:26');
INSERT INTO `oj_problem_submit` VALUES ('21', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:08:47');
INSERT INTO `oj_problem_submit` VALUES ('22', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 19:12:30');
INSERT INTO `oj_problem_submit` VALUES ('23', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:18:58');
INSERT INTO `oj_problem_submit` VALUES ('24', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 19:21:26');
INSERT INTO `oj_problem_submit` VALUES ('25', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 19:52:23');
INSERT INTO `oj_problem_submit` VALUES ('26', '1', '1', 'echo \"                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\";', '7', 'PE', '0', null, null, '2023-12-11 20:14:17');
INSERT INTO `oj_problem_submit` VALUES ('27', '1', '1', '<?php\r\necho \"                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\";', '7', 'PE', '0', null, null, '2023-12-11 20:14:55');
INSERT INTO `oj_problem_submit` VALUES ('28', '1', '1', '#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n\r\n{\r\n\r\n    cout<<\"                ********\"<<endl;\r\n\r\n    cout<<\"               ************\"<<endl;\r\n\r\n    cout<<\"               ####....#.\"<<endl;\r\n\r\n    cout<<\"             #..###.....##....\"<<endl;\r\n\r\n    cout<<\"             ###.......######              ###                 ###           ###           ###\"<<endl;\r\n\r\n    cout<<\"                ...........               #...#               #...#         #...#         #...#\"<<endl;\r\n\r\n    cout<<\"               ##*#######                 #.#.#               #.#.#         #.#.#         #.#.#\"<<endl;\r\n\r\n    cout<<\"            ####*******######             #.#.#               #.#.#         #.#.#         #.#.#\"<<endl;\r\n\r\n    cout<<\"           ...#***.****.*###....          #...#               #...#         #...#         #...#\"<<endl;\r\n\r\n    cout<<\"           ....**********##.....           ###                 ###           ###           ###\"<<endl;\r\n\r\n    cout<<\"           ....****    *****....\"<<endl;\r\n\r\n    cout<<\"             ####        ####\"<<endl;\r\n\r\n    cout<<\"           ######        ######\"<<endl;\r\n\r\n    cout<<\"##############################################################              ##################################\"<<endl;\r\n\r\n    cout<<\"#...#......#.##...#......#.##...#......#.##------------------#              #...#......#.##------------------#\"<<endl;\r\n\r\n    cout<<\"###########################################------------------#              ###############------------------#\"<<endl;\r\n\r\n    cout<<\"#..#....#....##..#....#....##..#....#....#####################              #..#....#....#####################\"<<endl;\r\n\r\n    cout<<\"##########################################    #----------#                  ##############    #----------#\"<<endl;\r\n\r\n    cout<<\"#.....#......##.....#......##.....#......#    #----------#                  #.....#......#    #----------#\"<<endl;\r\n\r\n    cout<<\"##########################################    #----------#                  ##############    #----------#\"<<endl;\r\n\r\n    cout<<\"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#                  #.#..#....#..#    #----------#\"<<endl;\r\n\r\n    cout<<\"##########################################    ############                  ##############    ############\"<<endl;\r\n\r\n    return 0;\r\n\r\n}', '1', 'WE', '0', null, null, '2023-12-11 20:16:03');
INSERT INTO `oj_problem_submit` VALUES ('29', '1', '1', 'ptint(\'\'\'                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\'\'\')', '6', 'PE', '0', null, null, '2023-12-11 20:19:17');
INSERT INTO `oj_problem_submit` VALUES ('30', '1', '2', 'print(\'Hello, World!\') #注意逗号后空一格', '6', 'AC', '100', null, null, '2023-12-11 20:20:59');
INSERT INTO `oj_problem_submit` VALUES ('31', '1', '3', '#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n    char a;\r\n    a=getchar();\r\n    for(int i=-2;i<=2;i++)\r\n    {\r\n        for(int j=1;j<=abs(i);j++)\r\n            cout<<\" \";\r\n        for(int j=1;j<=5-abs(i*2);j++)\r\n            putchar(a);\r\n        cout<<endl;\r\n    }\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 20:22:15');
INSERT INTO `oj_problem_submit` VALUES ('32', '1', '4', '#include <stdio.h>\r\n#include <string.h>\r\nint main()\r\n{\r\n    int n = 0;//变量的声明与读入\r\n    char a[105][55] = {0}, b[55] = {0};\r\n    while (scanf(\"%s\", b) != EOF)\r\n    {\r\n        strcpy(a[n], b);\r\n        n++;//记录读入的字符串数量\r\n    }\r\n    n--;//！=EOF多读了一个空字符串\r\n \r\n    for (int i = 0; i < n; i++)//冒泡排序\r\n    {\r\n        for (int j = 0; j < n - i; j++)\r\n        {\r\n            if (strcmp(a[j], a[j + 1]) >= 0)//比较大小，strcmp()功能：字符串比较\r\n            {\r\n                strcpy(b, a[j]);//swap  strcpy()功能：将字符串从一个地方复制到另外一个地方\r\n                strcpy(a[j], a[j + 1]);\r\n                strcpy(a[j + 1], b);\r\n            }\r\n        }\r\n    }\r\n    \r\n    for (int i = 0; i <= n; i++)\r\n    {\r\n        if (strcmp(a[i], a[i + 1]) != 0)//相同字符串只输出一次\r\n            printf(\"%s\\n\", a[i]);\r\n    }\r\n \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:29:50');
INSERT INTO `oj_problem_submit` VALUES ('33', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:30:43');
INSERT INTO `oj_problem_submit` VALUES ('34', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 20:31:52');
INSERT INTO `oj_problem_submit` VALUES ('35', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:32:42');
INSERT INTO `oj_problem_submit` VALUES ('36', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:45:44');
INSERT INTO `oj_problem_submit` VALUES ('37', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:48:22');
INSERT INTO `oj_problem_submit` VALUES ('38', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:49:09');
INSERT INTO `oj_problem_submit` VALUES ('39', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 20:50:09');
INSERT INTO `oj_problem_submit` VALUES ('40', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:03:35');
INSERT INTO `oj_problem_submit` VALUES ('41', '1', '2', 'print(\'Hello, World!\') #注意逗号后空一格', '1', 'PE', '0', null, null, '2023-12-11 21:04:00');
INSERT INTO `oj_problem_submit` VALUES ('42', '1', '2', 'print(\'Hello, World!\') #注意逗号后空一格', '6', 'AC', '100', null, null, '2023-12-11 21:04:41');
INSERT INTO `oj_problem_submit` VALUES ('43', '1', '2', 'print(\'Hello, World!\') #注意逗号后空一格', '6', 'AC', '100', null, null, '2023-12-11 21:05:22');
INSERT INTO `oj_problem_submit` VALUES ('44', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:06:09');
INSERT INTO `oj_problem_submit` VALUES ('45', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:07:30');
INSERT INTO `oj_problem_submit` VALUES ('46', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:08:32');
INSERT INTO `oj_problem_submit` VALUES ('47', '1', '4', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'PE', '0', null, null, '2023-12-11 21:09:58');
INSERT INTO `oj_problem_submit` VALUES ('48', '1', '5', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-11 21:10:29');
INSERT INTO `oj_problem_submit` VALUES ('49', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:11:25');
INSERT INTO `oj_problem_submit` VALUES ('50', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:15:48');
INSERT INTO `oj_problem_submit` VALUES ('51', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:17:17');
INSERT INTO `oj_problem_submit` VALUES ('52', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:18:34');
INSERT INTO `oj_problem_submit` VALUES ('53', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:25:08');
INSERT INTO `oj_problem_submit` VALUES ('54', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:25:58');
INSERT INTO `oj_problem_submit` VALUES ('55', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:28:59');
INSERT INTO `oj_problem_submit` VALUES ('56', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 21:36:29');
INSERT INTO `oj_problem_submit` VALUES ('57', '1', '6', '#include<bits/stdc++.h>\r\nusing namespace std;\r\nint n,b[1001],a[1001],k,s;\r\nint main()\r\n{\r\n    scanf(\"%d\",&n);\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        scanf(\"%d\",&a[i]);\r\n    }\r\n    for(int i=1;i<=n-1;i++)//排序算法，将数组元素升序排列\r\n    {\r\n        for(int j=i+1;j<=n;j++)\r\n        {\r\n            if(a[i]>a[j])\r\n            {\r\n                swap(a[i],a[j]);\r\n            }\r\n        }\r\n    }\r\n    for(int i=1;i<=n;i++)//统计奇数个数，以便输出逗号\r\n    {\r\n        if(a[i]%2==1)\r\n        {\r\n            s++;\r\n        }\r\n    }\r\n    for(int i=1;i<=n;i++)//最后输出\r\n    {\r\n        if(a[i]%2==1)\r\n        {\r\n            k++;\r\n             if(k==s)\r\n             {\r\n                cout<<a[i];\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                cout<<a[i]<<\",\";\r\n            }\r\n        }\r\n    }\r\n}', '1', 'PE', '20', null, null, '2023-12-11 21:42:11');
INSERT INTO `oj_problem_submit` VALUES ('58', '1', '6', 'import java.util.Scanner;\r\n\r\npublic class Main \r\n\r\n{\r\n\r\npublic static void main(String[] args) \r\n\r\n{\r\n\r\nScanner sc = new Scanner(System.in);\r\n\r\nint n=sc.nextInt();\r\n\r\nint []a=new int[501];\r\n\r\nint b=0;\r\n\r\nfor(int i=0;i<n;i++)\r\n\r\n{\r\n\r\n    a[i]=sc.nextInt();\r\n\r\n}\r\n\r\nfor(int i=0;i<n;i++)\r\n\r\n{\r\n\r\n    int t=a[i];\r\n\r\n    for(int j=i+1;j<n;j++)\r\n\r\n    {\r\n\r\n        if(t>a[j])\r\n\r\n        {\r\n\r\n            t=a[j];\r\n\r\n            a[j]=a[i];\r\n\r\n            a[i]=t;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nfor(int i=0;i<n;i++)\r\n\r\n{\r\n\r\n    if(a[i]%2!=0)\r\n\r\n    {\r\n\r\n        b++;\r\n\r\n        if(b==1)System.out.print(a[i]);\r\n\r\n        if(b>1)System.out.print(\",\"+a[i]);\r\n\r\n    }\r\n\r\n}\r\n\r\n}\r\n\r\n}', '3', 'AC', '100', null, null, '2023-12-11 21:43:02');
INSERT INTO `oj_problem_submit` VALUES ('59', '1', '7', '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct student\r\n{\r\n    char m[20];\r\n    int g;\r\n}S;\r\nbool cmp(S x1,S x2)\r\n{\r\n    if(x1.g==x2.g)\r\n        for(int i=0;i<20;i++)\r\n            if(x1.m[i]>x2.m[i])\r\n                return false;\r\n    else if(x1.m[i]<x2.m[i])\r\n        return true;\r\n    return x1.g>x2.g;\r\n}\r\nint main()\r\n{\r\n    int n,k;\r\n    cin>>n;\r\n    S a[21];\r\n    for(int i=0;i<n;i++)\r\n        cin>>a[i].m>>a[i].g;\r\n    sort(a,a+n,cmp);\r\n    for(int i=0;i<n;i++)\r\n        cout<<a[i].m<<\" \"<<a[i].g<<endl;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:44:36');
INSERT INTO `oj_problem_submit` VALUES ('60', '1', '101', '#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a;\r\n    cin>>a;\r\n    cout<<(long long)pow(2,a);\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:45:32');
INSERT INTO `oj_problem_submit` VALUES ('61', '1', '101', '#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a;\r\n    cin>>a;\r\n    cout<<(long long)pow(2,a);\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:46:11');
INSERT INTO `oj_problem_submit` VALUES ('62', '1', '6', '#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n    int b[501]={0},a[252]={0};\r\n    int n,count=0,t;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n        {cin>>b[i];\r\n        if(b[i]%2!=0)\r\n            {a[count]=b[i];\r\n            count++;}}\r\nsort(a,a+count);\r\n    for(int i=0;i<count-1;i++)\r\n        printf(\"%d,\",a[i]);\r\n    printf(\"%d\",a[count-1]);\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:47:28');
INSERT INTO `oj_problem_submit` VALUES ('63', '1', '7', '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct student\r\n{\r\n    char m[20];\r\n    int g;\r\n}S;\r\nbool cmp(S x1,S x2)\r\n{\r\n    if(x1.g==x2.g)\r\n        for(int i=0;i<20;i++)\r\n            if(x1.m[i]>x2.m[i])\r\n                return false;\r\n    else if(x1.m[i]<x2.m[i])\r\n        return true;\r\n    return x1.g>x2.g;\r\n}\r\nint main()\r\n{\r\n    int n,k;\r\n    cin>>n;\r\n    S a[21];\r\n    for(int i=0;i<n;i++)\r\n        cin>>a[i].m>>a[i].g;\r\n    sort(a,a+n,cmp);\r\n    for(int i=0;i<n;i++)\r\n        cout<<a[i].m<<\" \"<<a[i].g<<endl;\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 21:48:11');
INSERT INTO `oj_problem_submit` VALUES ('64', '1', '8', '#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef struct Stu {\r\n    int hao;//学号\r\n    int a;//语文成绩\r\n    int b;//数学成绩\r\n    int c;//英语成绩\r\n    int sum;//总分\r\n};//将学生的信息封装成结构体\r\nint cmp1(Stu s1, Stu s2) { //自定义排序准则\r\n    return s1.sum > s2.sum || (s1.sum == s2.sum && s1.a > s2.a) || (s1.c == s2.c && s1.hao < s2.hao);\r\n    //如果两个同学总分相同，再按语文成绩从高到低排序\r\n    //如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面\r\n}\r\nint main() {\r\n    int n;\r\n    cin >> n;\r\n    Stu stu[n];\r\n    for (int i = 0; i < n; i++) { //输入学生信息\r\n        cin >> stu[i].a >> stu[i].b >> stu[i].c;\r\n        stu[i].sum = stu[i].a + stu[i].b + stu[i].c; //计算总分\r\n        stu[i].hao = i + 1; //学号记得加一\r\n    }\r\n    stable_sort(stu, stu + n, cmp1); //排序\r\n    //stable的函数可保证相等元素的原本相对次序在排序后保持不变\r\n    for (int i = 0; i < 5; i++) { //输出前五名\r\n        cout << stu[i].hao << \" \" << stu[i].sum << endl;\r\n    }\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 22:55:16');
INSERT INTO `oj_problem_submit` VALUES ('65', '1', '9', '#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\ntypedef struct student\r\n{\r\n    int id;\r\n    int mark;\r\n}stu;\r\nstu a[5001],temp[5001];\r\nint main()\r\n{\r\n    int n,m,mian,i,j,k,s=0;\r\n    cin>>n>>m;\r\n    mian=floor(m*1.5);\r\n    for(i=0;i<n;i++)\r\n        cin>>a[i].id>>a[i].mark;\r\n    for(j=1;j<i;j++)\r\n        for(k=0;k<i-j;k++)\r\n        {\r\n            if(a[k+1].mark>a[k].mark)\r\n            {\r\n               temp[1]=a[k+1];\r\n               a[k+1]=a[k];\r\n               a[k]=temp[1];\r\n            }\r\n            else if(a[k+1].mark==a[k].mark&&a[k+1].id<a[k].id)\r\n            {\r\n                temp[1]=a[k+1];\r\n                a[k+1]=a[k];\r\n                a[k]=temp[1];\r\n            }\r\n        }\r\n    for(int p=0;p<i;p++)\r\n        if(a[p].mark>=a[mian].mark)\r\n            s++;\r\n    cout<<a[mian].mark<<\" \"<<s<<endl;\r\n    for(int q=0;q<s;q++)\r\n        cout<<a[q].id<<\" \"<<a[q].mark<<endl;\r\n    return 0;\r\n}', '1', 'PE', '60', null, null, '2023-12-11 22:56:39');
INSERT INTO `oj_problem_submit` VALUES ('66', '1', '9', '#include<stdio.h>\r\n\r\nstruct xs {\r\n\r\nint id;\r\n\r\nint mark;\r\n\r\n};\r\n\r\nstruct xs x[5001];\r\n\r\nstruct xs t;\r\n\r\nint main() {\r\n\r\nint n, m;\r\n\r\nint i, j;\r\n\r\nscanf(\"%d %d\", &n, &m);\r\n\r\nfor (i = 0; i < n; i++) {\r\n\r\nscanf(\"%d %d\", &x[i].id, &x[i].mark);\r\n\r\n}\r\n\r\nm *= 1.5;\r\n\r\nfor (i = 0; i < n - 1; i++) {\r\n\r\nfor (j = 0; j < n - i; j++) {\r\n\r\nif (x[j].mark < x[j + 1].mark) {\r\n\r\nt = x[j];\r\n\r\nx[j] = x[j + 1];\r\n\r\nx[j + 1] = t;\r\n\r\n} else if (x[j].mark == x[j + 1].mark) {\r\n\r\nif (x[j].id > x[j + 1].id) {\r\n\r\nt = x[j];\r\n\r\nx[j] = x[j + 1];\r\n\r\nx[j + 1] = t;\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n// printf(\"\\n\");\r\n\r\n// for(i=0;i<n;i++){\r\n\r\n// printf(\"%d %d\\n\",x[i].id,x[i].mark);\r\n\r\n// }\r\n\r\nint s=0;\r\n\r\nfor (i = 0; i < n; i++) {\r\n\r\nif(x[i].mark>=x[m].mark){\r\n\r\ns++;\r\n\r\n}\r\n\r\n}\r\n\r\nprintf(\"%d %d\\n\", x[m].mark,s);\r\n\r\nfor (i = 0; i < s; i++) {\r\n\r\nprintf(\"%d %d\\n\", x[i].id, x[i].mark);\r\n\r\n}\r\n\r\n\r\n\r\n}\r\n\r\n', '1', 'PE', '60', null, null, '2023-12-11 22:58:07');
INSERT INTO `oj_problem_submit` VALUES ('67', '1', '10', '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int odd[10],even[10],num,i,j,l=0,r=0;\r\n    for(i=0;i<10;i++)\r\n    {\r\n        cin>>num;\r\n        if(num%2!=0)\r\n            odd[l++]=num;\r\n        else\r\n            even[r++]=num;\r\n    }\r\n    for(i=0;i<l;i++)\r\n        for(j=i;j<l;j++)\r\n            if(odd[j]>odd[i])\r\n            {\r\n                odd[i]+=odd[j];\r\n                odd[j]=odd[i]-odd[j];\r\n                odd[i]-=odd[j];\r\n            }\r\n    for(i=0;i<r;i++)\r\n        for(j=i;j<r;j++)\r\n            if(even[j]<even[i])\r\n            {\r\n                even[i]+=even[j];\r\n                even[j]=even[i]-even[j];\r\n                even[i]-=even[j];\r\n            }\r\n    for(i=0;i<l;i++)\r\n        cout<<odd[i]<<\" \";\r\n    for(i=0;i<r;i++)\r\n        cout<<even[i]<<\" \";\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 22:58:55');
INSERT INTO `oj_problem_submit` VALUES ('68', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 23:01:56');
INSERT INTO `oj_problem_submit` VALUES ('69', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 23:03:58');
INSERT INTO `oj_problem_submit` VALUES ('70', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'WE', '78', null, null, '2023-12-11 23:04:24');
INSERT INTO `oj_problem_submit` VALUES ('71', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:05:59');
INSERT INTO `oj_problem_submit` VALUES ('72', '1', '4', '#include <iostream>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\nint main(){\r\n    string s[105];\r\n    set<string> ss;//利用set集合去重 \r\n    int n=0;\r\n    while(cin>>s[n]){\r\n        n++;\r\n    }\r\n    sort(s,s+n);//利用sort排序 \r\n    for(int i=0;i<n;i++){\r\n        ss.insert(s[i]);\r\n    }\r\n    for(set<string>::iterator it=ss.begin();it!=ss.end();it++){//迭代器，遍历集合中的元素 \r\n        cout<<*it<<endl;\r\n    } \r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:06:51');
INSERT INTO `oj_problem_submit` VALUES ('73', '1', '1', '#include<stdio.h>\r\nint main() {\r\n    printf(\r\n    \"                ********\\n\"\r\n    \"               ************\\n\"\r\n    \"               ####....#.\\n\"\r\n    \"             #..###.....##....\\n\"\r\n    \"             ###.......######              ###            ###\\n\"\r\n    \"                ...........               #...#          #...#\\n\"\r\n    \"               ##*#######                 #.#.#          #.#.#\\n\"\r\n    \"            ####*******######             #.#.#          #.#.#\\n\"\r\n    \"           ...#***.****.*###....          #...#          #...#\\n\"\r\n    \"           ....**********##.....           ###            ###\\n\"\r\n    \"           ....****    *****....\\n\"\r\n    \"             ####        ####\\n\"\r\n    \"           ######        ######\\n\"\r\n    \"##############################################################\\n\"\r\n    \"#...#......#.##...#......#.##...#......#.##------------------#\\n\"\r\n    \"###########################################------------------#\\n\"\r\n    \"#..#....#....##..#....#....##..#....#....#####################\\n\"\r\n    \"##########################################    #----------#\\n\"\r\n    \"#.....#......##.....#......##.....#......#    #----------#\\n\"\r\n    \"##########################################    #----------#\\n\"\r\n    \"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\\n\"\r\n    \"##########################################    ############\\n\"\r\n    );\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:08:58');
INSERT INTO `oj_problem_submit` VALUES ('74', '1', '1', '#include <bits/stdc++.h>\r\nusing namespace std;\r\nint mp[100][100];\r\nint last[100];\r\nint n = 22, m = 62;\r\n// 在[x1-x2, y1-y2]绘制ch\r\nvoid draw(int x1, int y1, int x2, int y2, char ch = \'#\'){\r\n    for(int i = x1; i <= x2; i++)\r\n        for(int j = y1; j <= y2; j++)\r\n            mp[i][j] = ch;\r\n}\r\n// 在[x1, y1]绘制ch\r\nvoid draw(int x1, int y1, char ch = \'#\'){\r\n    draw(x1, y1, x1, y1, ch);\r\n}\r\n// 以[x, y]为左上角绘制泥土\r\nvoid drawland(int x, int y){\r\n    draw(x, y, x+8, y+13);\r\n    for(int i = x+1; i < x+8; i+=2)\r\n        draw(i, y+1, i, y+12, \'.\');\r\n    draw(x+1, y+4); draw(x+1, y+11);\r\n    draw(x+3, y+3); draw(x+3, y+8);\r\n    draw(x+5, y+6); draw(x+7, y+2);\r\n    draw(x+7, y+5); draw(x+7, y+10);\r\n}\r\n// 以[x, y]为左上角绘制小岛\r\nvoid drawisland(int x, int y){\r\n    draw(x, y, x+3, y+19);\r\n    draw(x+1, y+1, x+2, y+18, \'-\');\r\n    draw(x+4, y+4, x+8, y+15);\r\n    draw(x+4, y+5, x+7, y+14, \'-\');\r\n}\r\n// 以[x, y]为左上角绘制金币\r\nvoid drawcoin(int x, int y){\r\n    draw(x, y, x+5, y+4);\r\n    draw(x+1, y+1, x+4, y+3, \'.\');\r\n    draw(x+2, y+2, x+3, y+2);\r\n    draw(x, y, \' \'); draw(x+5, y, \' \');\r\n    draw(x, y+4, \' \'); draw(x+5, y+4, \' \');\r\n}\r\n// 以[x, y]为左上角绘制马里奥\r\nvoid drawman(int x, int y){\r\n    draw(x, y+5, x, y+12, \'*\'); x++;\r\n    draw(x, y+4, x, y+15, \'*\'); x++;\r\n    draw(x, y+4, x, y+7); draw(x, y+8, x, y+13, \'.\'); draw(x, y+12); x++;\r\n    draw(x, y+2, x, y+14); draw(x, y+3, x, y+4, \'.\');\r\n    draw(x, y+8, x, y+12, \'.\'); draw(x, y+15, x, y+18, \'.\'); x++;\r\n    draw(x, y+2, x, y+17); draw(x, y+5, x, y+11, \'.\'); x++;\r\n    draw(x, y+5, x, y+15, \'.\'); x++;\r\n    draw(x, y+4, x, y+13); draw(x, y+6, \'*\'); x++;\r\n    draw(x, y+1, x, y+17); draw(x, y+5, x, y+11, \'*\'); x++;\r\n    draw(x, y, x+2, y+20, \'.\'); draw(x, y+4, x+2, y+16, \'*\');\r\n    draw(x, y+3); draw(x, y+14, x+1, y+16); draw(x+1, y+16, \'.\');\r\n    draw(x+2, y+8, x+2, y+11, \' \'); draw(x, y+7, \'.\'); draw(x, y+12, \'.\');\r\n    draw(x+3, y, x+4, y+19); draw(x+3, y+6, x+4, y+13, \' \');\r\n    draw(x+3, y, x+3, y+1, \' \'); draw(x+3, y+18, x+3, y+19, \' \');\r\n}\r\n// 打印输出\r\nvoid printscreen(){\r\n    for(int i = 1; i <= n; i++){\r\n        last[i] = m;\r\n        while(mp[i][last[i]] == \' \')\r\n            last[i]--;\r\n    }\r\n    for(int i = 1; i <= n; i++,puts(\"\"))\r\n        for(int j = 1; j <= last[i]; j++)\r\n            putchar(mp[i][j]);\r\n}\r\nint main(){\r\n    for(int i = 1; i <= n; i++)\r\n        for(int j = 1; j <= m; j++)\r\n            mp[i][j] = \' \';\r\n    // 绘制人\r\n    drawman(1, 12);\r\n    // 绘制他脚下的三块泥土\r\n    drawland(14, 1); drawland(14, 15); drawland(14, 29);\r\n    // 绘制金币下面的那个岛屿\r\n    drawisland(14, 43);\r\n    // 绘制两个金币\r\n    drawcoin(5, 43); drawcoin(5, 58);\r\n    // 输出\r\n    printscreen();\r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:09:24');
INSERT INTO `oj_problem_submit` VALUES ('75', '1', '1', '#include<iostream>\r\nint main()\r\n{\r\n    std::cout<<R\"(                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############ )\";\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:09:49');
INSERT INTO `oj_problem_submit` VALUES ('76', '1', '1', 'print(\"\"\"                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\"\"\")', '6', 'AC', '100', null, null, '2023-12-11 23:10:09');
INSERT INTO `oj_problem_submit` VALUES ('77', '1', '7', '#include <stdio.h>\ntypedef struct score{\n    char name[20];\n    int sc;\n}score;\nint main()\n{   \n    int n;\n    scanf(\"%d\",&n);\n    score arr[n];\n    for(int i=n-1;i>=0;i--){\n        scanf(\"%s \",arr[i].name);\n        scanf(\"%d\",&arr[i].sc);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(arr[i].sc<arr[j].sc){\n                score t = arr[j];\n                arr[j] = arr[i];\n                arr[i] = t;\n            }\n        }\n        \n    }\n    for(int i=0;i<n;i++){\n        printf(\"%s %d\\n\",arr[i].name,arr[i].sc);\n    }\n    return 0;\n}', '1', 'WE', '30', null, null, '2023-12-11 23:29:09');
INSERT INTO `oj_problem_submit` VALUES ('78', '1', '7', '#include <stdio.h>\ntypedef struct score{\n    char name[20];\n    int sc;\n}score;\nint main()\n{   \n    int n;\n    scanf(\"%d\",&n);\n    score arr[n];\n    for(int i=n-1;i>=0;i--){\n        scanf(\"%s \",arr[i].name);\n        scanf(\"%d\",&arr[i].sc);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(arr[i].sc<=arr[j].sc){\n                score t = arr[j];\n                arr[j] = arr[i];\n                arr[i] = t;\n            }\n        }\n        \n    }\n    for(int i=0;i<n;i++){\n        printf(\"%s %d\\n\",arr[i].name,arr[i].sc);\n    }\n    return 0;\n}', '1', 'WE', '50', null, null, '2023-12-11 23:31:27');
INSERT INTO `oj_problem_submit` VALUES ('79', '1', '7', '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nstruct S {\r\n    char name[20];\r\n    int score;\r\n};\r\nint main(void) {\r\n    int n;\r\n    scanf(\"%d\", &n);\r\n \r\n    S* s = (S*)malloc(sizeof(S) * (n + 1));\r\n    for (int i = 1; i <= n; i++) {\r\n        scanf(\"%s\", s[i].name, sizeof(s[i].name));\r\n        scanf(\"%d\", &s[i].score);\r\n         \r\n        int end = i - 1;\r\n        S stu = s[i];\r\n        while (end >= 1) {\r\n            if (stu.score > s[end].score) {\r\n                s[end + 1] = s[end];\r\n                end--;\r\n            }\r\n            else if (stu.score == s[end].score) {\r\n                if (strcmp(stu.name, s[end].name) < 0) {\r\n                    s[end + 1] = s[end];\r\n                    end--;\r\n                } else \r\n                break;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        s[end + 1] = stu;\r\n    }\r\n \r\n    for (int i = 1; i <= n; i++)\r\n        printf(\"%s %d\\n\", s[i].name, s[i].score);\r\n \r\n    return 0;\r\n}', '1', 'AC', '100', null, null, '2023-12-11 23:36:35');
INSERT INTO `oj_problem_submit` VALUES ('80', '1', '137', '#include <stdio.h>\nint R(int x,int r){\n    int a = 0,i=1;\n    while(x){\n        a+=(x%r)*i;\n        x=x/r;\n        i*=10;\n    }\n    return a;\n}\nint reverseR(int x,int r){\n    int a = 0;\n    while(x){\n        a*=10;\n        a+=x%r;\n        x/=r;\n    }\n    return a;\n}\n\nint main()\n{\n    int a,b;\n    for(int i=81;i<7*7*7;i++){\n            if(R(i,7)==reverseR(i,9))\n                printf(\"%d\\n%d\\n%d\",i,R(i,7),R(i,9));\n    }\n    return 0;\n}', '1', 'AC', '100', null, null, '2023-12-12 00:04:03');
INSERT INTO `oj_problem_submit` VALUES ('81', '1', '11', '#include <stdio.h>\nint main()\n{\n    int a,b;\n    while(~scanf(\"%d%d\", &a, &b))printf(\"%d\\n\",a+b);\n    return 0;\n}', '1', 'WE', '0', null, null, '2023-12-12 12:49:12');
INSERT INTO `oj_problem_submit` VALUES ('84', '1', '7', '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nstruct S {\r\n    char name[20];\r\n    int score;\r\n};\r\nint main(void) {\r\n    int n;\r\n    scanf(\"%d\", &n);\r\n \r\n    S* s = (S*)malloc(sizeof(S) * (n + 1));\r\n    for (int i = 1; i <= n; i++) {\r\n        scanf(\"%s\", s[i].name, sizeof(s[i].name));\r\n        scanf(\"%d\", &s[i].score);\r\n         \r\n        int end = i - 1;\r\n        S stu = s[i];\r\n        while (end >= 1) {\r\n            if (stu.score > s[end].score) {\r\n                s[end + 1] = s[end];\r\n                end--;\r\n            }\r\n            else if (stu.score == s[end].score) {\r\n                if (strcmp(stu.name, s[end].name) < 0) {\r\n                    s[end + 1] = s[end];\r\n                    end--;\r\n                } else \r\n                break;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        s[end + 1] = stu;\r\n    }\r\n \r\n    for (int i = 1; i <= n; i++)\r\n        printf(\"%s %d\\n\", s[i].name, s[i].score);\r\n \r\n    return 0;\r\n}', '1', 'AC', '100', '1156', '6', '2023-12-12 13:25:13');
INSERT INTO `oj_problem_submit` VALUES ('83', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-12 13:23:58');
INSERT INTO `oj_problem_submit` VALUES ('85', '1', '7', '#include <stdio.h>\r\ntypedef struct score{\r\n    char name[20];\r\n    int sc;\r\n}score;\r\nint main()\r\n{   \r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    score arr[n];\r\n    for(int i=n-1;i>=0;i--){\r\n        scanf(\"%s \",arr[i].name);\r\n        scanf(\"%d\",&arr[i].sc);\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        for(int j=i;j<n;j++){\r\n            if(arr[i].sc<=arr[j].sc){\r\n                score t = arr[j];\r\n                arr[j] = arr[i];\r\n                arr[i] = t;\r\n            }\r\n        }\r\n        \r\n    }\r\n    for(int i=0;i<n;i++){\r\n        printf(\"%s %d\\n\",arr[i].name,arr[i].sc);\r\n    }\r\n    return 0;\r\n}', '1', 'WE', '50', '1156', '6', '2023-12-12 13:26:33');
INSERT INTO `oj_problem_submit` VALUES ('86', '1', '1', 'print(\"\"\"                ********\r\n               ************\r\n               ####....#.\r\n             #..###.....##....\r\n             ###.......######              ###            ###\r\n                ...........               #...#          #...#\r\n               ##*#######                 #.#.#          #.#.#\r\n            ####*******######             #.#.#          #.#.#\r\n           ...#***.****.*###....          #...#          #...#\r\n           ....**********##.....           ###            ###\r\n           ....****    *****....\r\n             ####        ####\r\n           ######        ######\r\n##############################################################\r\n#...#......#.##...#......#.##...#......#.##------------------#\r\n###########################################------------------#\r\n#..#....#....##..#....#....##..#....#....#####################\r\n##########################################    #----------#\r\n#.....#......##.....#......##.....#......#    #----------#\r\n##########################################    #----------#\r\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\r\n##########################################    ############\"\"\")', '6', 'AC', '100', '35260', '78', '2023-12-12 14:54:15');
INSERT INTO `oj_problem_submit` VALUES ('87', '1', '8', '#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef struct Stu {\r\n    int hao;//学号\r\n    int a;//语文成绩\r\n    int b;//数学成绩\r\n    int c;//英语成绩\r\n    int sum;//总分\r\n};//将学生的信息封装成结构体\r\nint cmp1(Stu s1, Stu s2) { //自定义排序准则\r\n    return s1.sum > s2.sum || (s1.sum == s2.sum && s1.a > s2.a) || (s1.c == s2.c && s1.hao < s2.hao);\r\n    //如果两个同学总分相同，再按语文成绩从高到低排序\r\n    //如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面\r\n}\r\nint main() {\r\n    int n;\r\n    cin >> n;\r\n    Stu stu[n];\r\n    for (int i = 0; i < n; i++) { //输入学生信息\r\n        cin >> stu[i].a >> stu[i].b >> stu[i].c;\r\n        stu[i].sum = stu[i].a + stu[i].b + stu[i].c; //计算总分\r\n        stu[i].hao = i + 1; //学号记得加一\r\n    }\r\n    stable_sort(stu, stu + n, cmp1); //排序\r\n    //stable的函数可保证相等元素的原本相对次序在排序后保持不变\r\n    for (int i = 0; i < 5; i++) { //输出前五名\r\n        cout << stu[i].hao << \" \" << stu[i].sum << endl;\r\n    }\r\n    return 0;\r\n}', '1', 'AC', '100', '2092', '11', '2023-12-12 14:55:35');
INSERT INTO `oj_problem_submit` VALUES ('88', '1', '5', '#include<iostream>\r\nusing namespace std;\r\nstruct s\r\n{\r\n    int xuehao;\r\n    double chengji;\r\n};\r\nint main()\r\n{\r\n    s ppp[101];\r\n    int n,k;\r\n    cin>>n>>k;\r\n    for(int i=1;i<=n;i++)\r\n        cin>>ppp[i].xuehao>>ppp[i].chengji;\r\n    for(int i=1;i<n;i++)\r\n        for(int j=n-1;j>=i;j--)\r\n            if(ppp[j].chengji<ppp[j+1].chengji)\r\n            {\r\n                ppp[j].xuehao+=ppp[j+1].xuehao;\r\n                ppp[j+1].xuehao=ppp[j].xuehao-ppp[j+1].xuehao;\r\n                ppp[j].xuehao-=ppp[j+1].xuehao;\r\n                ppp[j].chengji+=ppp[j+1].chengji;\r\n                ppp[j+1].chengji=ppp[j].chengji-ppp[j+1].chengji;\r\n                ppp[j].chengji-=ppp[j+1].chengji;\r\n            }\r\n    cout<<ppp[k].xuehao<<\" \"<<ppp[k].chengji;\r\n    return 0;\r\n}', '1', 'AC', '100', '2084', '8', '2023-12-12 14:56:18');
INSERT INTO `oj_problem_submit` VALUES ('89', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-12 19:47:46');
INSERT INTO `oj_problem_submit` VALUES ('90', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '16', '2023-12-13 00:02:55');
INSERT INTO `oj_problem_submit` VALUES ('91', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '9', '2023-12-13 00:04:53');
INSERT INTO `oj_problem_submit` VALUES ('92', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '6', '2023-12-13 00:05:43');
INSERT INTO `oj_problem_submit` VALUES ('93', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-13 00:07:51');
INSERT INTO `oj_problem_submit` VALUES ('94', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '7', '2023-12-13 00:08:41');
INSERT INTO `oj_problem_submit` VALUES ('95', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '6', '2023-12-13 00:15:25');
INSERT INTO `oj_problem_submit` VALUES ('96', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-13 00:24:13');
INSERT INTO `oj_problem_submit` VALUES ('97', '3', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-13 13:28:32');
INSERT INTO `oj_problem_submit` VALUES ('98', '1', '1', '#include <stdio.h>\nint main()\n{\n    while(1);\n    return 0;\n}', '1', 'PE', '0', '1048', '9503', '2023-12-13 18:11:31');
INSERT INTO `oj_problem_submit` VALUES ('99', '1', '1', '#include <stdio.h>\nint main()\n{\n    while(1);\n    return 0;\n}', '1', 'TLE', '0', '1048', '9506', '2023-12-13 18:11:58');
INSERT INTO `oj_problem_submit` VALUES ('100', '1', '10', '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int odd[10],even[10],num,i,j,l=0,r=0;\r\n    for(i=0;i<10;i++)\r\n    {\r\n        cin>>num;\r\n        if(num%2!=0)\r\n            odd[l++]=num;\r\n        else\r\n            even[r++]=num;\r\n    }\r\n    for(i=0;i<l;i++)\r\n        for(j=i;j<l;j++)\r\n            if(odd[j]>odd[i])\r\n            {\r\n                odd[i]+=odd[j];\r\n                odd[j]=odd[i]-odd[j];\r\n                odd[i]-=odd[j];\r\n            }\r\n    for(i=0;i<r;i++)\r\n        for(j=i;j<r;j++)\r\n            if(even[j]<even[i])\r\n            {\r\n                even[i]+=even[j];\r\n                even[j]=even[i]-even[j];\r\n                even[i]-=even[j];\r\n            }\r\n    for(i=0;i<l;i++)\r\n        cout<<odd[i]<<\" \";\r\n    for(i=0;i<r;i++)\r\n        cout<<even[i]<<\" \";\r\n    return 0;\r\n}', '1', 'AC', '100', '2084', '14', '2023-12-18 10:40:55');
INSERT INTO `oj_problem_submit` VALUES ('101', '1', '9', '#include<stdio.h>\r\n\r\nstruct xs {\r\n\r\nint id;\r\n\r\nint mark;\r\n\r\n};\r\n\r\nstruct xs x[5001];\r\n\r\nstruct xs t;\r\n\r\nint main() {\r\n\r\nint n, m;\r\n\r\nint i, j;\r\n\r\nscanf(\"%d %d\", &n, &m);\r\n\r\nfor (i = 0; i < n; i++) {\r\n\r\nscanf(\"%d %d\", &x[i].id, &x[i].mark);\r\n\r\n}\r\n\r\nm *= 1.5;\r\n\r\nfor (i = 0; i < n - 1; i++) {\r\n\r\nfor (j = 0; j < n - i; j++) {\r\n\r\nif (x[j].mark < x[j + 1].mark) {\r\n\r\nt = x[j];\r\n\r\nx[j] = x[j + 1];\r\n\r\nx[j + 1] = t;\r\n\r\n} else if (x[j].mark == x[j + 1].mark) {\r\n\r\nif (x[j].id > x[j + 1].id) {\r\n\r\nt = x[j];\r\n\r\nx[j] = x[j + 1];\r\n\r\nx[j + 1] = t;\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n// printf(\"\\n\");\r\n\r\n// for(i=0;i<n;i++){\r\n\r\n// printf(\"%d %d\\n\",x[i].id,x[i].mark);\r\n\r\n// }\r\n\r\nint s=0;\r\n\r\nfor (i = 0; i < n; i++) {\r\n\r\nif(x[i].mark>=x[m].mark){\r\n\r\ns++;\r\n\r\n}\r\n\r\n}\r\n\r\nprintf(\"%d %d\\n\", x[m].mark,s);\r\n\r\nfor (i = 0; i < s; i++) {\r\n\r\nprintf(\"%d %d\\n\", x[i].id, x[i].mark);\r\n\r\n}\r\n\r\n\r\n\r\n}', '1', 'PE', '60', '1196', '58', '2023-12-18 10:42:26');
INSERT INTO `oj_problem_submit` VALUES ('102', '1', '11', '#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n	float m[45];//男生身高数组\r\n	float w[45];\r\n	int n/*题意可知*/,mp = 0/*男生身高数组下标*/,wp = 0/*女生身高数组下标*/;\r\n	cin>>n;\r\n	for(int i = 0;i<n;i++){\r\n		char k[8];\r\n		float l;\r\n		cin>>k>>l;\r\n		if(k[0] == \'m\'){//如果首字母是m就是男生\r\n			m[mp] = l;//丢到男生数组\r\n			mp++;//下标向下移动\r\n		}else{//反之，就是女生\r\n			w[wp] = l;\r\n			wp++;//女生下标++\r\n		}\r\n	}\r\n	sort(m,m+mp);\r\n	sort(w,w+wp);\r\n	for(int i = 0;i<mp;i++){\r\n		printf(\"%.2f \",m[i]);\r\n	}\r\n	for(int i = wp-1;i>=0;i--){\r\n		printf(\"%.2f \",w[i]);\r\n	}\r\n}\r\n', '1', 'PE', '0', '0', '0', '2023-12-18 10:44:21');
INSERT INTO `oj_problem_submit` VALUES ('103', '1', '11', '#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n;\r\n    double d;\r\n    char s[20];\r\n    double a[50],b[50];\r\n    int p=0,q=0;\r\n    double temp;\r\n    int i,j;\r\n    \r\n    \r\n    cin>>n;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        cin>>s>>d;\r\n        if(strcmp(s,\"male\")==0)\r\n            a[p++]=d;\r\n        else \r\n            b[q++]=d;\r\n    }\r\n    \r\n    for(i=0;i<p;i++)\r\n        for(j=i+1;j<p;j++)\r\n            if(a[i]>a[j])\r\n            {\r\n                temp=a[i];\r\n                a[i]=a[j];\r\n                a[j]=temp;\r\n            }\r\n            \r\n    for(i=0;i<q;i++)\r\n        for(j=i+1;j<q;j++)\r\n            if(b[i]<b[j])\r\n            {\r\n                temp=b[i];\r\n                b[i]=b[j];\r\n                b[j]=temp;\r\n            }\r\n            \r\n    for(i=0;i<p;i++)\r\n        printf(\"%.2lf \",a[i]);\r\n    for(i=0;i<q;i++)\r\n        printf(\"%.2lf \",b[i]);\r\n    return 0;\r\n}', '1', 'AC', '100', '2088', '13', '2023-12-18 10:45:25');
INSERT INTO `oj_problem_submit` VALUES ('104', '1', '12', '#include<iostream>\r\nusing namespace std;\r\ntypedef struct a\r\n{\r\n    char m[20];\r\n    int age;\r\n}T;\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    T a[101];\r\n    for(int i=1;i<=n;i++)\r\n        cin>>a[i].m>>a[i].age;\r\n    for(int j=n;j>=1;j--)\r\n        for(int t=n;t>n-j+1;t--)\r\n            if((a[t].age>a[t-1].age)&&a[t].age>=60)\r\n            {\r\n                T temp=a[t];\r\n                a[t]=a[t-1];\r\n                a[t-1]=temp;\r\n            }\r\n    for(int i=1;i<=n;i++)\r\n        cout<<a[i].m<<\" \"<<endl;\r\n    return 0;\r\n}', '1', 'AC', '100', '2084', '14', '2023-12-18 10:47:13');
INSERT INTO `oj_problem_submit` VALUES ('105', '1', '13', 'import java.util.Scanner;\r\npublic class L1102 {\r\n    static int n;\r\npublic static void main(String[] args) {\r\n    Scanner m=new Scanner (System.in);\r\n     n=m.nextInt();\r\n    int array[]=new int[n];\r\n    int number=0;\r\n    for(int i=0;i<array.length;i++)\r\n    {\r\n        int temp=m.nextInt();\r\n        int flag=0;\r\n        for(int k=0;k<array.length;k++)\r\n        {\r\n            if(temp==array[k])\r\n                flag++;\r\n        }\r\n        if(flag==0)\r\n        {\r\n            array[i]=temp;\r\n            number++;\r\n        }          \r\n    }\r\n//for(int h=0;h<array.length;h++)\r\n//  System.out.print(array[h]+\" \");\r\n     \r\n    for(int i=0;i<array.length-1;i++)\r\n        for(int k=i+1;k<array.length;k++)\r\n            if(array[i]>array[k])\r\n            {\r\n                int temp=array[i];\r\n                array[i]=array[k];\r\n                array[k]=temp;\r\n            }\r\n//  System.out.println();\r\n    System.out.println(number);\r\n    for(int k=0;k<array.length-1;k++)\r\n    if(array[k]!=0)\r\n    System.out.print(array[k]+\" \");\r\n    System.out.println(array[array.length-1]);\r\n \r\n}\r\n}', '3', 'PE', '0', '0', '0', '2023-12-18 10:48:56');
INSERT INTO `oj_problem_submit` VALUES ('106', '1', '13', '#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quickSort(int arr[], int start, int end); // 快速排序\r\nvoid duplicateRemoval(int arr[], int len); // 去重并输出剩余元素个数\r\nint main() {\r\n    int N = 0; // 随机数个数\r\n    cin >> N;\r\n    int arr[N] = { 0 }; // 存储随机数\r\n    for (int i = 0; i < N; i++) {\r\n        cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, N - 1); // 先排序\r\n    duplicateRemoval(arr, N); // 后去重\r\n    for (int i = 0; i < N; i++) {\r\n        if (arr[i]) {\r\n            cout << arr[i] << \" \";\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n \r\nvoid quickSort(int arr[], int start, int end) {\r\n    // 这一步很关键，写成==都无法输出，因为到只剩1个元素时start == left，但传入参数为start和left - 1\r\n    if (start >= end) {\r\n        return;\r\n    }\r\n    int pivot = arr[start]; // 基准值\r\n    int left = start; // 从左向右遍历找比pivot大的数\r\n    int right = end;  // 从右向左遍历找比pivot小的数\r\n    while (left < right) {\r\n        while (left < right && arr[right] >= pivot) {\r\n            right--; // 找到比pivot小的数\r\n        }\r\n        if (left < right) {\r\n            arr[left] = arr[right]; // 移动到left位置，因为left的值已经传给pivot了\r\n        }\r\n        while (left < right && arr[left] <= pivot) {\r\n            left++; // 找到比pivot大的数\r\n        }\r\n        if (left < right) {\r\n            arr[right] = arr[left]; // 移动到right位置，因为right的值已经传给left了\r\n        }\r\n    }\r\n    arr[left] = pivot; // left和right相遇，把基准值放到这里，至此就实现了左边都比pivot小，右边都比pivot大\r\n    quickSort(arr, start, left - 1);\r\n    quickSort(arr, right + 1, end);\r\n}\r\n \r\nvoid duplicateRemoval(int arr[], int len) {\r\n    int count = len; // 剩余元素个数\r\n    for (int i = 0; i < len - 1; i++) {\r\n        if (arr[i] == arr[i + 1]) {\r\n            arr[i] = 0; // 由于题目要求随机数均为正整数，所以归零就算是去重了\r\n            count--;\r\n        }\r\n    }\r\n    cout << count << endl; // 输出剩余个数\r\n}\r\n', '1', 'AC', '100', '2084', '5', '2023-12-18 10:49:49');
INSERT INTO `oj_problem_submit` VALUES ('107', '1', '13', '# 完整版\r\ninput()  #\r\nlis = list(set( [int(i) for i in input().split()] ))\r\nlis.sort()\r\nlis = list(map(str,lis))\r\nprint(len(lis))\r\nprint(\' \'.join(lis))', '6', 'AC', '100', '35260', '201', '2023-12-18 10:50:31');
INSERT INTO `oj_problem_submit` VALUES ('108', '1', '13', 'import java. util. ArrayList;\r\nimport java. util. Arrays;\r\nimport java. util. Scanner ;\r\npublic class Main {\r\n    public static void 1102(String[] args) {\r\n        Scanner sc=new Scanner (System. in) ;\r\n        int a=sc. nextInt() ;\r\n        ArrayList<Integer> list=new ArrayList<Integer>() ;\r\n        int [] arr=new int [a] ;\r\n        //录入数据\r\n        for(int i=0;i<a;i++)\r\n        {\r\n            arr[i]=sc. nextInt() ;\r\n        }\r\n        //去重\r\n        for(int i=0;i<a;i++)\r\n        {\r\n            if(!list. contains (arr[i]))\r\n            {\r\n                list. add(arr[i]);\r\n            }\r\n        }\r\n        //集合转数组\r\n        0bject[] arr1=list. toArray();\r\n        //升序排列\r\n        Arrays. sort(arr1) ;\r\n        System. out. print1n (arr1. length) ;\r\n        for (Object i :arr1)\r\n        {\r\n            System. out. print(i+\" \");\r\n        }\r\n    }\r\n}', '3', 'PE', '0', '0', '0', '2023-12-18 10:51:25');
INSERT INTO `oj_problem_submit` VALUES ('109', '1', '13', 'import java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Scanner ;\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Scanner sc=new Scanner (System. in) ;\r\n        int a=sc.nextInt() ;\r\n        ArrayList<Integer> list=new ArrayList<Integer>() ;\r\n        int [] arr=new int [a] ;\r\n        //录入数据\r\n        for(int i=0;i<a;i++)\r\n        {\r\n            arr[i]=sc.nextInt() ;\r\n        }\r\n        //去重\r\n        for(int i=0;i<a;i++)\r\n        {\r\n            if(!list. contains (arr[i]))\r\n            {\r\n                list.add(arr[i]);\r\n            }\r\n        }\r\n        //集合转数组\r\n        0bject[] arr1=list. toArray();\r\n        //升序排列\r\n        Arrays.sort(arr1) ;\r\n        System.out.print1n (arr1.length) ;\r\n        for (Object i :arr1)\r\n        {\r\n            System.out.print(i+\" \");\r\n        }\r\n    }\r\n}', '3', 'PE', '0', '0', '0', '2023-12-18 10:52:32');
INSERT INTO `oj_problem_submit` VALUES ('110', '1', '13', 'import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\npublic class Main {\r\n    /**\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        // TODO Auto-generated method stub\r\n        Scanner scanner=new Scanner(System.in);\r\n        int n=scanner.nextInt();\r\n        List<Integer> list=new ArrayList<Integer>();\r\n        for (int i = 0; i < n; i++) {\r\n            int x=scanner.nextInt();\r\n            if (!list.contains(x)) {//不添加重复数据\r\n                list.add(x);\r\n            }\r\n        }\r\n        Collections.sort(list);//排序\r\n        System.out.println(list.size());\r\n        for (Integer i : list) {\r\n            System.out.print(i+\" \");\r\n        }\r\n    }\r\n}', '3', 'AC', '100', '19399', '700', '2023-12-18 10:53:43');
INSERT INTO `oj_problem_submit` VALUES ('111', '1', '2', '<?php\r\n\r\necho(\"Hello World!\");\r\n\r\n?>', '7', 'PE', '0', '0', '0', '2023-12-18 10:54:47');
INSERT INTO `oj_problem_submit` VALUES ('112', '1', '13', '#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quickSort(int arr[], int start, int end); // 快速排序\r\nvoid duplicateRemoval(int arr[], int len); // 去重并输出剩余元素个数\r\nint main() {\r\n    int N = 0; // 随机数个数\r\n    cin >> N;\r\n    int arr[N] = { 0 }; // 存储随机数\r\n    for (int i = 0; i < N; i++) {\r\n        cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, N - 1); // 先排序\r\n    duplicateRemoval(arr, N); // 后去重\r\n    for (int i = 0; i < N; i++) {\r\n        if (arr[i]) {\r\n            cout << arr[i] << \" \";\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n \r\nvoid quickSort(int arr[], int start, int end) {\r\n    // 这一步很关键，写成==都无法输出，因为到只剩1个元素时start == left，但传入参数为start和left - 1\r\n    if (start >= end) {\r\n        return;\r\n    }\r\n    int pivot = arr[start]; // 基准值\r\n    int left = start; // 从左向右遍历找比pivot大的数\r\n    int right = end;  // 从右向左遍历找比pivot小的数\r\n    while (left < right) {\r\n        while (left < right && arr[right] >= pivot) {\r\n            right--; // 找到比pivot小的数\r\n        }\r\n        if (left < right) {\r\n            arr[left] = arr[right]; // 移动到left位置，因为left的值已经传给pivot了\r\n        }\r\n        while (left < right && arr[left] <= pivot) {\r\n            left++; // 找到比pivot大的数\r\n        }\r\n        if (left < right) {\r\n            arr[right] = arr[left]; // 移动到right位置，因为right的值已经传给left了\r\n        }\r\n    }\r\n    arr[left] = pivot; // left和right相遇，把基准值放到这里，至此就实现了左边都比pivot小，右边都比pivot大\r\n    quickSort(arr, start, left - 1);\r\n    quickSort(arr, right + 1, end);\r\n}\r\n \r\nvoid duplicateRemoval(int arr[], int len) {\r\n    int count = len; // 剩余元素个数\r\n    for (int i = 0; i < len - 1; i++) {\r\n        if (arr[i] == arr[i + 1]) {\r\n            arr[i] = 0; // 由于题目要求随机数均为正整数，所以归零就算是去重了\r\n            count--;\r\n        }\r\n    }\r\n    cout << count << endl; // 输出剩余个数\r\n}', '1', 'AC', '100', '2084', '8', '2023-12-18 11:36:09');
INSERT INTO `oj_problem_submit` VALUES ('113', '1', '2', '#include <stdio.h>\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}', '1', 'AC', '100', '1048', '4', '2023-12-26 09:56:26');

-- ----------------------------
-- Table structure for oj_user
-- ----------------------------
DROP TABLE IF EXISTS `oj_user`;
CREATE TABLE `oj_user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `limits` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of oj_user
-- ----------------------------
INSERT INTO `oj_user` VALUES ('1', 'admin', 'e10adc3949ba59abbe56e057f20f883e', '123456@qq.com', '9');
INSERT INTO `oj_user` VALUES ('2', '1', 'e10adc3949ba59abbe56e057f20f883e', '54554@qq.com', '0');
INSERT INTO `oj_user` VALUES ('3', '2', 'e10adc3949ba59abbe56e057f20f883e', '54554@qq.com', '0');

-- ----------------------------
-- Table structure for oj_user_info
-- ----------------------------
DROP TABLE IF EXISTS `oj_user_info`;
CREATE TABLE `oj_user_info` (
  `id` int(11) NOT NULL,
  `sign` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `exp` int(11) DEFAULT NULL,
  `grade` int(11) DEFAULT NULL,
  `ranking` int(11) DEFAULT NULL,
  `submit_all` int(11) DEFAULT NULL,
  `submit_ac` int(11) DEFAULT NULL,
  `submit_pro` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
-- Records of oj_user_info
-- ----------------------------
INSERT INTO `oj_user_info` VALUES ('1', '你好！我是网站管理员', '330', '5', '1', '111', '51', '14');
INSERT INTO `oj_user_info` VALUES ('2', null, '0', '1', '3', '0', '0', '0');
INSERT INTO `oj_user_info` VALUES ('3', null, '10', '2', '2', '1', '1', '1');
